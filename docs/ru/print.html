<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CLEO Redux</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="relation-to-cleo-library.html"><strong aria-hidden="true">1.1.</strong> Связь с CLEO Library</a></li></ol></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Установка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation-classic-games.html"><strong aria-hidden="true">2.1.</strong> Для классических GTA III, GTA VC, GTA SA</a></li><li class="chapter-item expanded "><a href="installation-re3-revc.html"><strong aria-hidden="true">2.2.</strong> Для re3 и reVC</a></li><li class="chapter-item expanded "><a href="installation-definitive-edition.html"><strong aria-hidden="true">2.3.</strong> Для The Definitive Edition</a></li><li class="chapter-item expanded "><a href="cleo-directory.html"><strong aria-hidden="true">2.4.</strong> Папка CLEO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation-plugins.html"><strong aria-hidden="true">2.4.1.</strong> Плагины</a></li><li class="chapter-item expanded "><a href="installation-scripts.html"><strong aria-hidden="true">2.4.2.</strong> Скрипты</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.</strong> Конфигурация</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="permissions.html"><strong aria-hidden="true">3.1.</strong> Разрешения</a></li></ol></li><li class="chapter-item expanded "><a href="scripts.html"><strong aria-hidden="true">4.</strong> Скрипты</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compiled-scripts.html"><strong aria-hidden="true">4.1.</strong> Compiled Scripts (.cs)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom-commands.html"><strong aria-hidden="true">4.1.1.</strong> Пользовательские команды</a></li></ol></li><li class="chapter-item expanded "><a href="javascript.html"><strong aria-hidden="true">4.2.</strong> JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prerequisites.html"><strong aria-hidden="true">4.2.1.</strong> Предварительные условия</a></li><li class="chapter-item expanded "><a href="script-lifecycle.html"><strong aria-hidden="true">4.2.2.</strong> Жизненный цикл скрипта</a></li><li class="chapter-item expanded "><a href="fluent-interface.html"><strong aria-hidden="true">4.2.3.</strong> Свободный интерфейс</a></li><li class="chapter-item expanded "><a href="imports.html"><strong aria-hidden="true">4.2.4.</strong> Импорт</a></li><li class="chapter-item expanded "><a href="js-bindings.html"><strong aria-hidden="true">4.2.5.</strong> Привязки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="script-object-vs-object.html"><strong aria-hidden="true">4.2.5.1.</strong> ScriptObject vs Object</a></li><li class="chapter-item expanded "><a href="using-math.html"><strong aria-hidden="true">4.2.5.2.</strong> Math Object</a></li><li class="chapter-item expanded "><a href="using-memory.html"><strong aria-hidden="true">4.2.5.3.</strong> Memory Object</a></li><li class="chapter-item expanded "><a href="using-memory-64.html"><strong aria-hidden="true">4.2.5.4.</strong> Memory Object (x64)</a></li><li class="chapter-item expanded "><a href="deprecated-bindings.html"><strong aria-hidden="true">4.2.5.5.</strong> Устаревшее</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">5.</strong> Поиск проблемы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="log.html"><strong aria-hidden="true">5.1.</strong> Лог</a></li><li class="chapter-item expanded "><a href="the-definitive-edition-faq.html"><strong aria-hidden="true">5.2.</strong> Поддержка The Definitive Edition</a></li></ol></li><li class="chapter-item expanded "><a href="other-features.html"><strong aria-hidden="true">6.</strong> Другие особенности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="using-fxt.html"><strong aria-hidden="true">6.1.</strong> Пользовательский текст (FXT)</a></li><li class="chapter-item expanded "><a href="unsupported.html"><strong aria-hidden="true">6.2.</strong> Неподдерживаемые функции</a></li><li class="chapter-item expanded "><a href="embedding.html"><strong aria-hidden="true">6.3.</strong> Встраивание в пользовательский хост</a></li></ol></li><li class="chapter-item expanded "><a href="using-sdk.html"><strong aria-hidden="true">7.</strong> SDK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cpp-sdk.html"><strong aria-hidden="true">7.1.</strong> C++ SDK</a></li><li class="chapter-item expanded "><a href="rust-sdk.html"><strong aria-hidden="true">7.2.</strong> Rust SDK</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CLEO Redux</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cleolibrary/CLEO-Redux" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<p>CLEO Redux — это среда выполнения сценариев для игр эпохи GTA 3D. Это полноценный член семейства CLEO, который предоставляет знакомый опыт всем, кто использовал библиотеку CLEO для классической GTA San Andreas или ее повторные реализации для других игр. Основная цель CLEO — предоставить возможность легко настраивать игру с помощью многочисленных пользовательских скриптов.</p>
<p>Если вы новичок в CLEO, посетите <a href="https://cleo.li/">официальный сайт</a>, чтобы найти больше информации об этом.</p>
<h2 id="Поддерживаемые-релизы"><a class="header" href="#Поддерживаемые-релизы">Поддерживаемые релизы</a></h2>
<p>Классические:</p>
<ul>
<li>GTA III 1.0</li>
<li>GTA Vice City 1.0</li>
<li>GTA San Andreas 1.0 (только с <a href="https://github.com/cleolibrary/CLEO4">CLEO 4.4</a>)</li>
</ul>
<p>Ремастеры (The Trilogy):</p>
<ul>
<li>Title Update 1.03 и Title Update 1.04 (см. <a href="./the-definitive-edition-faq.html">детали</a>)</li>
</ul>
<p>Остальные:</p>
<ul>
<li>re3 (см. <a href="./troubleshooting.html#cleo-does-not-work-with-re3-or-revc">детали</a>)</li>
<li>reVC (см. <a href="./troubleshooting.html#cleo-does-not-work-with-re3-or-revc">детали</a>)</li>
</ul>
<p>CLEO Redux поддерживает только ПК-версию каждой игры.</p>
<p>Для получения полной информации о поддерживаемых функциях <a href="https://github.com/cleolibrary/CLEO-Redux/wiki/Feature-Support-Matrix">обратитесь к этой странице</a>.Также существуют известные ограничения <a href="unsupported.html">перечислены здесь</a>.</p>
<h2 id="Лицензия"><a class="header" href="#Лицензия">Лицензия</a></h2>
<p>CLEO Redux доступен по <a href="https://re.cleo.li/LICENSE.txt">лицензионному соглашению с конечным пользователем</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Связь-с-cleo-library"><a class="header" href="#Связь-с-cleo-library">Связь с CLEO Library</a></h1>
<p>CLEO — это общее название пользовательских библиотек, разработанных и созданных для GTA III, Vice City или San Andreas. Каждую версию можно найти и скачать <a href="https://cleo.li/download.html">здесь</a>. CLEO Redux — это <em>другая</em> реализация CLEO, созданная с нуля, с несколькими отличительными особенностями, такими как единая кодовая база для всех игр или поддержка кода JavaScript.</p>
<p>На данный момент CLEO Redux не может рассматриваться как полноценная замена CLEO Library из-за отсутствия поддержки многих широко используемых CLEO-команд. Чтобы решить эту проблему и получить максимальную отдачу от двух библиотек, CLEO Redux поддерживает две разные стратегии использования.</p>
<p>CLEO Redux может работать как отдельное ПО или как дополнение к CLEO Library. В первом случае ваша директория с игрой будет содержать только файл <code>cleo_redux.asi</code> (или <code>cleo_redux64.asi</code>). Во втором случае в вашем каталоге с игрой будут и <code>cleo.asi</code> (или <code>III.CLEO.asi</code>, и <code>VC.CLEO.asi</code>), и <code>cleo_redux.asi</code> (или <code>cleo_redux64.asi</code>).</p>
<h2 id="Запуск-cleo-redux-как-отдельного-ПО"><a class="header" href="#Запуск-cleo-redux-как-отдельного-ПО">Запуск CLEO Redux как отдельного ПО</a></h2>
<p>Как отдельное ПО CLEO Redux запускает скомпилированные скрипты и JavaScript и предоставляет доступ ко всем командам собственного скрипта. Он также предоставляет ограниченный набор <a href="./custom-commands.html">команд</a>, обратно совместимых с библиотекой CLEO. Существующие CLEO-скрипты могут не работать, если они используют пользовательские команды (например, из стороннего плагина), не поддерживаемые CLEO Redux.</p>
<p>Этот режим не работает в классической GTA San Andreas.</p>
<h2 id="Запуск-cleo-redux-в-качестве-дополнения-к-библиотеке-cleo"><a class="header" href="#Запуск-cleo-redux-в-качестве-дополнения-к-библиотеке-cleo">Запуск CLEO Redux в качестве дополнения к библиотеке CLEO</a></h2>
<p>В качестве дополнения CLEO Redux работает вместе с CLEO Library, делегируя ему всю заботу о пользовательских скриптах. Это означает, что все пользовательские скрипты и плагины, созданные для библиотеки CLEO, будут продолжать работать точно так же. CLEO Redux управляет только JS-скриптами. Все пользовательские команды становятся доступными для среды выполнения JavaScript, что означает, что вы можете использовать команды, которые в настоящее время не реализованы нативно в CLEO Redux, например, для <a href="https://library.sannybuilder.com/#/gta3/classes/File">файлов</a>.</p>
<p>Этот режим работает в классической GTA III, GTA Vice City и GTA San Andreas, где существует библиотека CLEO.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Установка"><a class="header" href="#Установка">Установка</a></h1>
<p>Порядок установки CLEO Redux может отличаться в зависимости от игры. Обратитесь к одному из нижеперечисленных гайдов:</p>
<ul>
<li><a href="./installation-classic-games.html">Классика GTA III, GTA VC, GTA SA</a></li>
<li><a href="./installation-re3-revc.html">re3 и reVC</a></li>
<li><a href="./installation-definitive-edition.html">The Trilogy: The Definitive Edition</a></li>
</ul>
<blockquote>
<p>Обратите внимание, что CLEO Redux распознает целевую игру исключительно по имени исполняемого файла, из которого она запускается. </p>
<ul>
<li>GTA III - <code>gta3.exe</code></li>
<li>GTA VC - <code>gta-vc.exe</code></li>
<li>GTA SA - <code>gta_sa.exe</code>, <code>gta-sa.exe</code>, or <code>gta_sa_compact.exe</code></li>
<li>re3 - <code>re3.exe</code></li>
<li>reVC - <code>reVC.exe</code></li>
<li>GTA 3: DE - <code>libertycity.exe</code></li>
<li>GTA VC: DE - <code>vicecity.exe</code></li>
<li>GTA SA: DE - <code>sanandreas.exe</code></li>
</ul>
<p>Сопоставление имен не зависит от регистра. Для классических игр CLEO Redux всегда предполагает версию 1.0. </p>
</blockquote>
<h2 id="Удаление"><a class="header" href="#Удаление">Удаление</a></h2>
<ul>
<li>Удалите <code>cleo_redux.asi</code> (или <code>cleo_redux64.asi</code>).</li>
<li>Удалите папку <code>CLEO</code> (необязательно).</li>
<li>Удалите <code>cleo_redux.log</code> (необязательно).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Классика-gta-iii-gta-vc-gta-sa"><a class="header" href="#Классика-gta-iii-gta-vc-gta-sa">Классика GTA III, GTA VC, GTA SA</a></h1>
<ul>
<li>
<p>Скопируйте <code>cleo_redux.asi</code> в папку с игрой.</p>
</li>
<li>
<p>Запустите игру, чтобы завершить установку</p>
</li>
</ul>
<p>Во время первого запуска игры может быть заметное отставание, так как CLEO Redux загружает файлы, необходимые для <a href="./javascript.html">поддержки JavaScript</a>. При последующих запусках этого не произойдет.</p>
<p>Также в папке с игрой* должна появиться новая папка с именем <code>CLEO</code>. Это основное место для всех CLEO-скриптов, плагинов и конфигов.</p>
<blockquote>
<p>Если CLEO не обладает правами на запись в директории <code>GTA San Andreas - Definitive Edition\Gameface\Binaries\Win64</code>, он будет использовать другой каталог в <code>C:\Users\&lt;ваше_имя&gt;\AppData\Roaming\CLEO Redux</code>. Там должен быть <code>cleo_redux.log</code> и папка CLEO, куда попадают все ваши скрипты.</p>
</blockquote>
<p>Примечание: CLEO Redux не изменяет игровые файлы. Он использует тот факт, что игра изначально загружает файлы <code>.asi</code> в качестве дополнений к библиотеке Miles Sound System. Никакого дополнительного ПО не требуется.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re3-и-revc"><a class="header" href="#re3-и-revc">re3 и reVC</a></h1>
<ul>
<li>
<p>Скопируйте <code>cleo_redux.asi</code> в папку с игрой.</p>
</li>
<li>
<p>Запустите игру, чтобы завершить установку</p>
</li>
</ul>
<p>Во время первого запуска игры может быть заметное отставание, так как CLEO Redux загружает файлы, необходимые для <a href="./javascript.html">поддержки JavaScript</a>. При последующих запусках этого не произойдет.</p>
<p>Также в папке с игрой* должна появиться новая папка с именем <code>CLEO</code>. Это основное место для всех CLEO-скриптов, плагинов и конфигов.</p>
<blockquote>
<p>Если CLEO не обладает правами на запись в директории <code>GTA San Andreas - Definitive Edition\Gameface\Binaries\Win64</code>, он будет использовать другой каталог в <code>C:\Users\&lt;ваше_имя&gt;\AppData\Roaming\CLEO Redux</code>. Там должен быть <code>cleo_redux.log</code> и папка CLEO, куда попадают все ваши скрипты.</p>
</blockquote>
<p>CLEO Redux поддерживает только «Windows D3D9 MSS 32bit» версию <code>re3</code> или <code>reVC</code>.</p>
<p>При запуске на <code>re3</code> и <code>reVC</code> убедитесь, что в каталоге игры есть файл <code>re3.pdb</code> (для <strong>re3</strong>) или <code>reVC.pdb</code> (для <strong>reVC</strong>). Из-за динамического характера адресов памяти в этих реализациях CLEO Redux использует отладочную информацию, хранящуюся в файле PDB, для правильного определения своего местоположения.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-definitive-edition"><a class="header" href="#the-definitive-edition">The Definitive Edition</a></h1>
<ul>
<li>
<p>Загрузите и установите <a href="https://github.com/ThirteenAG/Ultimate-ASI-Loader/releases/download/x64-latest/version.zip">Ultimate ASI Loader x64</a> от <a href="https://github.com/ThirteenAG">ThirteenAG</a> (поместите <code>version.dll</code> в каталог <code>Gameface\Binaries\Win64</code>).</p>
</li>
<li>
<p>Скопируйте <code>cleo_redux64.asi</code> в тот же каталог.</p>
</li>
<li>
<p>Запустите игру, чтобы завершить установку</p>
</li>
</ul>
<p>Во время первого запуска игры может быть заметное отставание, так как CLEO Redux загружает файлы, необходимые для <a href="./javascript.html">поддержки JavaScript</a>. При последующих запусках этого не произойдет.</p>
<p>Также в папке с игрой* должна появиться новая папка с именем <code>CLEO</code>. Это основное место для всех CLEO-скриптов, плагинов и конфигов.</p>
<blockquote>
<p>Если CLEO не обладает правами на запись в директории <code>GTA San Andreas - Definitive Edition\Gameface\Binaries\Win64</code>, он будет использовать другой каталог в <code>C:\Users\&lt;ваше_имя&gt;\AppData\Roaming\CLEO Redux</code>. Там должен быть <code>cleo_redux.log</code> и папка CLEO, куда попадают все ваши скрипты.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Папка-cleo"><a class="header" href="#Папка-cleo">Папка CLEO</a></h1>
<p>Папка CLEO — это основное место, куда вы устанавливаете <a href="./installation-scripts.html">CLEO-скрипты</a>, <a href="./installation-plugins.html">CLEO-плагины</a> и <a href="./using-fxt.html">пользовательские тексты</a>. CLEO Redux автоматически создает эту папку при запуске игры.</p>
<p>В большинстве случаев этот каталог можно найти в той же папке, куда вы поместили <code>cleo_redux.asi</code>. Однако, если CLEO не имеет прав на запись и не может создавать новые файлы, он использует альтернативный путь <code>C:\Users\&lt;ваше_имя_пользователя&gt;\AppData\Roaming\CLEO Redux</code>. Там можно найти <code>cleo_redux.log</code> и каталог <code>CLEO</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Плагины"><a class="header" href="#Плагины">Плагины</a></h1>
<p>Плагины — это необязательные программы, добавляющие дополнительные команды сценариев с помощью <a href="./using-sdk.html">CLEO Redux SDK</a>. Их расширение - <code>.cleo</code>.</p>
<p>Плагины следует копировать в директорию <code>CLEO\CLEO_PLUGINS</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Скрипты"><a class="header" href="#Скрипты">Скрипты</a></h1>
<h3 id="Добавление-нового-скрипта"><a class="header" href="#Добавление-нового-скрипта">Добавление нового скрипта</a></h3>
<p>Обычно файл скрипта нужно просто скопировать в каталог <code>CLEO</code>. Для установки некоторых скриптов могут потребоваться дополнительные действия. В случае каких-либо проблем проверьте документацию скрипта или обратитесь к его автору. </p>
<h3 id="Удаление-скрипта"><a class="header" href="#Удаление-скрипта">Удаление скрипта</a></h3>
<p>Удалите файл скрипта из каталога <code>CLEO</code>. Некоторые сценарии могут потребовать дополнительных действий для отмены установки. В случае каких-либо проблем проверьте документацию скрипта или обратитесь к его автору. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Конфигурация"><a class="header" href="#Конфигурация">Конфигурация</a></h1>
<p>CLEO Redux предоставляет некоторые настраиваемые параметры в файле <code>CLEO\.config\cleo.ini</code>.</p>
<ul>
<li><code>AllowCs</code> - при значении <code>1</code> CLEO загружает и выполняет файлы <code>*.cs</code>, расположенные в каталоге CLEO. Включено по умолчанию.</li>
<li><code>AllowJs</code> - при значении <code>1</code> CLEO загружает и выполняет файлы <code>*.js</code>, расположенные в каталоге CLEO. Включено по умолчанию.</li>
<li><code>AllowFxt</code> - при значении <code>1</code> CLEO загружает и <a href="./using-fxt.html">использует</a> файлы <code>*.fxt</code>, расположенные в каталоге CLEO\CLEO_TEXT. Включено по умолчанию.</li>
<li><code>CheckUpdates</code> - при значении <code>1</code> CLEO проверяет наличие нового обновления, доступного для скачивания, при запуске игры. Включено по умолчанию.</li>
<li><code>LogOpcodes</code> - при значении <code>1</code> CLEO регистрирует все выполненные опкоды в пользовательских скриптах. Этот журнал является частью файла <code>cleo_redux.log</code> (см. <a href="./log.html">Лог</a>)</li>
<li><code>PermissionLevel</code> - устанавливает уровень <a href="./permissions.html">разрешений</a> для небезопасных операций (см. ниже). По умолчанию используется «слабый».</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Разрешения"><a class="header" href="#Разрешения">Разрешения</a></h1>
<p>CLEO Redux признает некоторые <a href="./custom-commands.html">пользовательские команды</a> (коды операций) небезопасными и требует от пользователя решить, запускать их или нет. Необработанный доступ к памяти процесса, загрузка внешних библиотек или выполнение сетевых запросов могут быть вредными и вызывать нежелательные побочные эффекты. Поэтому CLEO вводит уровни разрешений для запуска небезопасного кода.</p>
<p>Доступны четыре уровня:</p>
<h2 id="all"><a class="header" href="#all">All</a></h2>
<p>Допускаются любые небезопасные операции. Используйте это только в том случае, если вы доверяете сценариям, которые запускаете.</p>
<h2 id="lax"><a class="header" href="#lax">Lax</a></h2>
<p>Это уровень разрешений по умолчанию.</p>
<p>Никакая небезопасная операция не разрешена, если сценарий явно не запрашивает ее. В настоящее время для запроса разрешения имя файла сценария должно включать маркеры разрешений, заключенные в квадратные скобки.</p>
<p>Например, если скрипт хочет получить доступ к памяти через <code>0A8D READ_MEMORY</code>, имя файла должно содержать <code>[mem]</code>, т.е. <code>крутой спаунер[mem].cs</code>. Если файл называется по-другому, CLEO отвергает <code>0A8D</code>, и скрипт вылетает.</p>
<h2 id="strict"><a class="header" href="#strict">Strict</a></h2>
<p>Никакая небезопасная операция не разрешена, если сценарий явно не запрашивает ее (см. <code>&quot;Слабые&quot;</code>), а файл конфигурации CLEO разрешает этот тип операции в разделе <code>Разрешения</code>. </p>
<p>Раздел разрешений в <code>cleo.ini</code> позволяет включать или отключать группы небезопасных операций с помощью токенов разрешений. Например,</p>
<pre><code class="language-ini">mem=0
</code></pre>
<p>отключает все коды операций, связанные с памятью, даже если скрипт имеет токен <code>[mem]</code> в имени файла.</p>
<p>Примечание. Раздел <code>Permissions</code> в <code>cleo.ini</code> вступает в силу только в том случае, если <code>PermissionLevel</code> имеет значение <code>Strict</code>.</p>
<h2 id="none"><a class="header" href="#none">None</a></h2>
<p>Небезопасная работа не допускается.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Скрипты-1"><a class="header" href="#Скрипты-1">Скрипты</a></h1>
<p>CLEO Redux предоставляет среду выполнения, способную выполнять <a href="./compiled-scripts.html">скомпилированные бинарные скрипты</a> (<code>*.cs</code>) в родном формате SCM и простые текстовые скрипты (<code>*.js</code>), написанные на <a href="./javascript.html">JavaScript</a>.</p>
<p>Чтобы найти информацию о том, как установить скрипты <a href="./installation-scripts.html">см. эту страницу</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Скомпилированные-скрипты"><a class="header" href="#Скомпилированные-скрипты">Скомпилированные скрипты</a></h1>
<p>CLEO Redux может выполнять скрипты, скомпилированные в родном для игры <a href="https://gtamods.com/wiki/SCM_Instruction">бинарном формате SCM</a>.  Такие скрипты имеют расширение <code>.cs</code>.  На них распространяются <a href="https://docs.sannybuilder.com/scm-documentation/gta-limits">ограничения</a> кода SCM.</p>
<p><a href="the-definitive-edition-faq.html#how-do-i-compile-cleo-scripts-with-sanny-builder">Проверьте FAQ</a> для получения информации о поддержке CS в обновленных играх.</p>
<h2 id="Написание-скомпилированного-скрипта"><a class="header" href="#Написание-скомпилированного-скрипта">Написание скомпилированного скрипта</a></h2>
<blockquote>
<p>Подробное пошаговое руководство <a href="https://gtamods.com/wiki/CLEO/Tutorial">посетите эту страницу</a>.  Это применимо к CLEO Redux.</p>
</blockquote>
<p>Для создания нового скрипта используйте <a href="https://sannybuilder.com">Sanny Builder 3</a> в режимах редактирования GTA III, GTA VC или GTA SA соответственно.  Добавьте директиву <code>{$CLEO .cs}</code> вверху вашего скрипта, напишите код и запустите «Скомпилировать и скопировать».  Sanny Builder создаст новый файл CS в каталоге CLEO.</p>
<p>На данный момент CLEO Redux предоставляет только несколько пользовательских команд.  Большинство команд, реализованных в CLEO Library или ее плагинах, пока недоступны.</p>
<p>Есть несколько основных правил, которым нужно следовать при написании скомпилированных скриптов:</p>
<ol>
<li>
<p>Один файл - один скрипт.  CLEO поддерживает только один скрипт на файл.</p>
</li>
<li>
<p>Никогда не используйте код операции <code>004E</code> для завершения сценария.  Этот код операции поддерживается только в <code>main.scm</code>.  Вместо этого используйте <a href="https://library.sannybuilder.com/#/sa/CLEO/0A93?p=1&amp;v=1">0A93</a>.</p>
</li>
<li>
<p>Минимизируйте использование глобальных переменных, поскольку они могут конфликтовать с другими скриптами. Можно использовать некоторые известные переменные, такие как <code>$PLAYER_CHAR</code>, <code>$PLAYER_ACTOR</code> и <code>$ONMISSION</code>.</p>
</li>
</ol>
<p>CLEO Redux не поддерживает сохранение статуса скрипта (функция CLEO Library) и добавлять эту функцию не планируется.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Пользовательские-команды"><a class="header" href="#Пользовательские-команды">Пользовательские команды</a></h1>
<blockquote>
<p>Примечание: Следующие команды предназначены только для классических игр. Для The Definitive Edition <a href="the-definitive-edition-faq.html#can-i-use-cleo-opcodes">проверьте эту информацию</a>.</p>
</blockquote>
<p>CLEO Redux поддерживает все оригинальные опкоды, доступные в данной игре.  Помимо них, он добавляет несколько новых команд, перечисленных ниже.  Обратите внимание, что они строго соответствуют опкодам библиотеки CLEO.</p>
<ul>
<li>0A8C <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A8C">WRITE_MEMORY</a> (<strong>НЕБЕЗОПАСНО</strong> - требует <code>mem</code> разрешение)</li>
<li>0A8D <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A8D">READ_MEMORY</a> (<strong>НЕБЕЗОПАСНО</strong> - требует <code>mem</code> разрешение)</li>
<li>0A8E <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A8E">INT_ADD</a></li>
<li>0A8F <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A8F">INT_SUB</a></li>
<li>0A90 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A90">INT_MUL</a></li>
<li>0A91 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A91">INT_DIV</a></li>
<li>0A93 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A93">TERMINATE_THIS_CUSTOM_SCRIPT</a></li>
<li>0AA5 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA5">CALL_FUNCTION</a> (<strong>НЕБЕЗОПАСНО</strong> - требует <code>mem</code> разрешение)</li>
<li>0AA6 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA6">CALL_FUNCTION_RETURN</a> (<strong>НЕБЕЗОПАСНО</strong> - требует <code>mem</code> разрешение)</li>
<li>0AA7 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA7">CALL_METHOD</a> (<strong>НЕБЕЗОПАСНО</strong> - требует <code>mem</code> разрешение)</li>
<li>0AA8 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA8">CALL_METHOD_RETURN</a> (<strong>НЕБЕЗОПАСНО</strong> - требует <code>mem</code> разрешение)</li>
<li>0AB0 <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AB0">IS_KEY_PRESSED</a></li>
</ul>
<p>Этот список может быть неполным, поскольку существуют специальные плагины с дополнительными командами (см. <a href="./using-sdk.html">Использование SDK</a>).  Обратитесь к <a href="https://library.sannybuilder.com">библиотеке Sanny Builder</a> для получения полного списка доступных команд для каждой игры.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>CLEO Redux ориентируется на JavaScript как на основной язык для пользовательских скриптов. JavaScript — популярный язык программирования с богатой экосистемой и большим количеством доступной информации. Он свободен от ограничений и ловушек языка SCM, таких как отсутствие поддержки функций, массивов или малое количество переменных.</p>
<p>Используйте VS Code (рекомендуется) или любой редактор по вашему выбору. Создайте новый файл с расширением <code>.js</code> и поместите его в папку CLEO. Дополнительную информацию см. в разделе <a href="javascript.html#%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-javascript">Поддержка JavaScript</a>.</p>
<p>Среда выполнения поддерживает сценарии в <a href="https://262.ecma-international.org/11.0/">стандарте ECMAScript 2020</a>. Это означает, что вы можете использовать самые последние функции JavaScript из коробки, такие как импорт, классы, стрелочные функции и т.д.</p>
<blockquote>
<p>CLEO Redux — это не Node.js. Не ожидайте, что здесь будут доступны сокеты, операции с файловой системой или другие функции Node.js.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Предварительные-условия"><a class="header" href="#Предварительные-условия">Предварительные условия</a></h1>
<p>Когда JavaScript включен, CLEO Redux требует определения команд с https://library.sannybuilder.com/. При первом запуске CLEO пытается загрузить их и поместить в вашу локальную директорию <code>CLEO/.config</code>. Если этого не произошло или вы не хотите, чтобы CLEO совершал сетевые вызовы, вручную скачайте необходимый файл (см. таблицу ниже) и поместите его в каталог <code>CLEO/.config</code>. </p>
<table><thead><tr><th>Игра</th><th>Файл</th><th>Минимальная требуемая версия</th></tr></thead><tbody>
<tr><td>GTA III, re3</td><td><a href="https://github.com/sannybuilder/library/blob/master/gta3/gta3.json">gta3.json</a></td><td><code>0.208</code></td></tr>
<tr><td>GTA VC, reVC</td><td><a href="https://github.com/sannybuilder/library/blob/master/vc/vc.json">vc.json</a></td><td><code>0.210</code></td></tr>
<tr><td>GTA San Andreas (Классика) 1.0</td><td><a href="https://github.com/sannybuilder/library/blob/master/sa/sa.json">sa.json</a></td><td><code>0.210</code></td></tr>
<tr><td>GTA III: The Definitive Edition</td><td><a href="https://github.com/sannybuilder/library/blob/master/gta3_unreal/gta3_unreal.json">gta3_unreal.json</a></td><td><code>0.210</code></td></tr>
<tr><td>Vice City: The Definitive Edition</td><td><a href="https://github.com/sannybuilder/library/blob/master/vc_unreal/vc_unreal.json">vc_unreal.json</a></td><td><code>0.212</code></td></tr>
<tr><td>San Andreas: The Definitive Edition</td><td><a href="https://github.com/sannybuilder/library/blob/master/sa_unreal/sa_unreal.json">sa_unreal.json</a></td><td><code>0.216</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Жизненный-цикл-скрипта"><a class="header" href="#Жизненный-цикл-скрипта">Жизненный цикл скрипта</a></h1>
<p>Файл с кодом JavaScript должен иметь расширение <code>*.js</code> и содержать известные инструкции, как описано ниже. Скрипт может не иметь инструкций (пустой скрипт). Он запускается, как только начинается новая игра или загружается файл сохранения.</p>
<p>Скрипт завершается автоматически после выполнения последней инструкции. Среда выполнения также завершает зависшие сценарии, чтобы игра не зависала. Застрявший скрипт — это тот, которому потребовалось более 2 секунд для запуска с момента последней команды ожидания. Если это произошло, проверьте свои циклы, в некоторых из них отсутствует команда ожидания.</p>
<pre><code class="language-js">while (true) {
  // бессмысленный бесконечный цикл, обычно зависающий в игре
  // будет завершено через две секунды
}
</code></pre>
<p>Среда выполнения завершит этот скрипт. Чтобы этого избежать, добавьте команду ожидания</p>
<pre><code class="language-js">while (true) {
  wait(250);
  // все равно бессмысленно, но не зависает в игре
}
</code></pre>
<h2 id="Организация-сценариев"><a class="header" href="#Организация-сценариев">Организация сценариев</a></h2>
<p>Один самодостаточный файл скрипта можно поместить прямо в <a href="https://re.cleo.li/docs/en/cleo-directory.html">директорию CLEO</a>.</p>
<p>Начиная с версии 0.9.3 сложные скрипты, имеющие множество зависимостей (импортированные файлы, словари <a href="https://re.cleo.li/docs/ru/using-fxt.html">FXT</a>), могут быть организованы в папки. CLEO Redux сканирует подкаталоги <a href="https://re.cleo.li/docs/en/cleo-directory.html">каталога CLEO</a> и проверяет, есть ли файл с именем <code>index.js</code>. Если <code>index.js</code> найден, CLEO Redux запускает его. Он также загружает все файлы FXT из того же каталога.</p>
<p>Давайте посмотрим на структуру примера:</p>
<pre><code>CLEO/
├─ CLEO_TEXT/
│  ├─ main.fxt
├─ папка A/
│  ├─ text.fxt
│  ├─ index.js
├─ папка B/
│  ├─ test.fxt
│  ├─ test.js
├─ script1.js
├─ script2.cs
</code></pre>
<p>По умолчанию CLEO Redux загружает все файлы CS и JS из корня каталога CLEO и файлы FXT из папки <code>CLEO_TEX</code>. Таким образом, он загружает <code>script1.js</code>, <code>script2.cs</code> и <code>main.fxt</code>.</p>
<p>После сканирования подкаталогов CLEO загружает <code>index.js</code> и <code>text.fxt</code>, находящиеся в <code>папке A</code>, и пропускает <code>папку B</code>, так как файла <code>index.js</code> нет.</p>
<p>CLEO_TEXT, CLEO_PLUGINS и .config не считаются каталогами скриптов.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Цепочки-методов"><a class="header" href="#Цепочки-методов">Цепочки методов</a></h1>
<p>Методы конструируемых сущностей (таких как <code>Player</code>, <code>Car</code>, <code>Char</code> – любые сущности, созданные с помощью метода конструктора) поддерживают цепочку (также известную как Fluent Interface). Это позволяет писать такой код:</p>
<pre><code class="language-js">var p = new Player(0);

p.giveWeapon(2, 100)
  .setHealth(5)
  .setCurrentWeapon(2)
  .getChar()
  .setCoordinates(1144, -600, 14)
  .setBleeding(true);
</code></pre>
<p>Посмотреть демонстрацию: https://www.youtube.com/watch?v=LLgJ0fWbklg.</p>
<p>Методы деструктора прерывают цепочку. Например. учитывая код:</p>
<p><code>Char.Create(0, 0, 0, 0, 0).setCoordinates(0, 0, 0).delete()</code></p>
<p>Цепочка не может продолжаться после метода удаления, так как символ удаляется, а его дескриптор больше не действителен.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Импорт"><a class="header" href="#Импорт">Импорт</a></h1>
<p>Вы можете импортировать другие файлы сценариев в свой код, чтобы сделать код модульным и использовать общую логику. Среда выполнения поддерживает оператор импорта, как описано в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">этой статье</a>.</p>
<p>Чтобы избежать запуска включенных файлов <code>.js</code> как отдельных скриптов, либо поместите их в отдельную папку (например, <code>CLEO/includes/</code>), либо используйте расширение <code>.mjs</code>.</p>
<pre><code class="language-js">// импортирует экспорт по умолчанию из other.js или other.mjs, расположенных в том же каталоге
import func from &quot;./other&quot;; 

// импортирует именованный экспорт PedType из types.js или types.mjs, расположенных в каталоге CLEO/includes
import { PedType } from &quot;./includes/types&quot;; 

// импортирует cars.json как значение JavaScript (массив, объект).
import data from &quot;./vehicles.json&quot;;
</code></pre>
<p>В настоящее время поддерживается только импорт файлов <code>.js</code> (<code>.mjs</code>) и <code>.json</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Привязки"><a class="header" href="#Привязки">Привязки</a></h1>
<p>Следующие переменные и функции доступны только в коде JavaScript.</p>
<h2 id="Переменные"><a class="header" href="#Переменные">Переменные</a></h2>
<h3 id="host"><a class="header" href="#host">HOST</a></h3>
<p>имя хоста (ранее доступное как переменная <code>GAME</code>).  Возможные значения включают <code>gta3</code>, <code>vc</code>, <code>re3</code>, <code>reVC</code>, <code>sa</code>, <code>gta3_unreal</code>, <code>vc_unreal</code>, <code>sa_unreal</code>, <code>unknown</code>. </p>
<p>Плагины CLEO могут использовать SDK для настройки имени под свои нужды.</p>
<pre><code class="language-js">if (HOST === &quot;gta3&quot;) {
  showTextBox(&quot;This is GTA III&quot;);
}
if (HOST === &quot;sa&quot;) {
  showTextBox(&quot;This is San Andreas&quot;);
}
if (HOST === &quot;unknown&quot;) {
  showTextBox(&quot;This host is not natively supported&quot;);
}
</code></pre>
<h3 id="onmission"><a class="header" href="#onmission">ONMISSION</a></h3>
<p>глобальный флаг, определяющий, находится ли игрок в данный момент на задании.  Недоступно на «неизвестном» хосте.</p>
<pre><code class="language-js">if (!ONMISSION) {
  showTextBox(&quot;Not on a mission. Setting ONMISSION to true&quot;);
  ONMISSION = true;
}
</code></pre>
<h3 id="timera-timerb"><a class="header" href="#timera-timerb">TIMERA, TIMERB</a></h3>
<p>два автоматически увеличивающихся таймера, полезных для измерения временных интервалов.</p>
<pre><code class="language-js">while (true) {
  TIMERA = 0;
  // wait 1000 ms
  while (TIMERA &lt; 1000) {
    wait(0);
  }
  showTextBox(&quot;1 second passed&quot;);
}
</code></pre>
<h3 id="__dirname"><a class="header" href="#__dirname">__dirname</a></h3>
<p>абсолютный путь к каталогу с текущим файлом</p>
<h3 id="__filename"><a class="header" href="#__filename">__filename</a></h3>
<p>(начиная с 0.9.4) абсолютный путь к текущему файлу</p>
<h2 id="Функции"><a class="header" href="#Функции">Функции</a></h2>
<h3 id="log"><a class="header" href="#log">log</a></h3>
<p><code>log(...значения)</code> печатает разделенные запятыми <code>{значения}</code> в <code>cleo_redux.log</code></p>
<pre><code class="language-js">var x = 1;
log(&quot;value of x is &quot;, x);
</code></pre>
<h3 id="wait"><a class="header" href="#wait">wait</a></h3>
<p><code>wait(время в миллисекундах)</code> приостанавливает выполнение скрипта как минимум на <code>{время в миллисекундах}</code> миллисекунд</p>
<pre><code class="language-js">while (true) {
  wait(1000);
  log(&quot;1 second passed&quot;);
}
</code></pre>
<h3 id="showtextbox"><a class="header" href="#showtextbox">showTextBox</a></h3>
<p><code>showTextBox(текст)</code> отображает <code>{текст}</code> в черном прямоугольном поле.  Недоступно на <code>неизвестном</code> хосте.</p>
<pre><code class="language-js">showTextBox(&quot;Hello, world!&quot;);
</code></pre>
<h3 id="exit"><a class="header" href="#exit">exit</a></h3>
<p><code>exit(причина?)</code> немедленно завершает скрипт.  Функция <code>exit</code> принимает необязательный строковый аргумент, который будет добавлен в <code>cleo_redux.log</code>.</p>
<pre><code class="language-js">exit(&quot;Script ended&quot;);
</code></pre>
<h3 id="native"><a class="header" href="#native">native</a></h3>
<p><code>native(имя команды, ...входные аргументы)</code> это низкоуровневая функция для выполнения команды с использованием ее имени <code>{имя команды}</code>. Имя команды соответствует свойству <code>name</code> в файле JSON, предоставленном библиотекой Sanny Builder.</p>
<pre><code class="language-js">native(&quot;SET_TIME_OF_DAY&quot;, 12, 30); // устанавливает время суток на 12:30
</code></pre>
<p>Для команд, возвращающих одно значение, результатом является это значение.</p>
<pre><code class="language-js">const progress = native(&quot;GET_PROGRESS_PERCENTAGE&quot;);
showTextBox(`Progress is ${progress}`);
</code></pre>
<p>Для команд, возвращающих несколько значений, результатом является объект, в котором каждый ключ соответствует возвращаемому значению. Имена ключей соответствуют именам выходов, указанным в определении команды.</p>
<pre><code class="language-js">var pos = native(&quot;GET_CHAR_COORDINATES&quot;, char); // возвращает вектор координат символа {x, y, z}
showTextBox(`Character pos: x ${pos.x} y ${pos.y} z ${pos.z}`);
</code></pre>
<p>Для условных команд результатом является логическое значение <code>true</code> или <code>false</code>.</p>
<pre><code class="language-js">if (native(&quot;HAS_MODEL_LOADED&quot;, 101)) {
  // проверяет условие
  showTextBox(&quot;Model with id 101 has been loaded&quot;);
}
</code></pre>
<h2 id="Статические-объекты"><a class="header" href="#Статические-объекты">Статические объекты</a></h2>
<h3 id="memory"><a class="header" href="#memory">Memory</a></h3>
<ul>
<li>Объект <code>Memory</code> позволяет манипулировать памятью процесса. См. <a href="using-memory.html">Руководство по памяти</a> для получения дополнительной информации.</li>
</ul>
<h3 id="math"><a class="header" href="#math">Math</a></h3>
<ul>
<li>Объект <code>Math</code> — это стандартный объект, доступный в среде выполнения JS, который обеспечивает общие математические операции. CLEO Redux расширяет его некоторыми дополнительными командами.  См. <a href="using-math.html">Объект Math</a> для получения дополнительной информации.</li>
</ul>
<h3 id="fxtstore"><a class="header" href="#fxtstore">FxtStore</a></h3>
<ul>
<li><code>FxtStore</code> позволяет обновлять содержимое внутриигровых текстов.  Подробнее см. в руководстве <a href="./using-fxt.html">Пользовательский текст</a>.</li>
</ul>
<h3 id="cleo"><a class="header" href="#cleo">CLEO</a></h3>
<ul>
<li>
<p>(начиная с 0.9.4) Объект <code>CLEO</code> предоставляет доступ к информации и утилитам во время выполнения:</p>
<ul>
<li><code>CLEO.debug.trace(флаг)</code> включает и выключает трассировку команд в текущем скрипте. Когда {флаг} имеет значение true, все выполненные команды добавляются в <code>cleo_redux.log</code>:</li>
</ul>
<pre><code class="language-js">  CLEO.debug.trace(true)
  wait(50);
  const p = new Player(0);
  CLEO.debug.trace(false)
</code></pre>
<ul>
<li><code>CLEO.version</code> - сложное свойство, предоставляющее информацию о текущей версии библиотеки</li>
</ul>
<pre><code class="language-js">  log(CLEO.version)       // &quot;0.9.4-dev.20220427&quot;
  log(CLEO.version.major) // &quot;0&quot;
  log(CLEO.version.minor) // &quot;9&quot;
  log(CLEO.version.patch) // &quot;4&quot;
  log(CLEO.version.pre)   // &quot;dev&quot;
  log(CLEO.version.build) // &quot;20220427&quot;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сравнение-scriptobject-и-object"><a class="header" href="#Сравнение-scriptobject-и-object">Сравнение ScriptObject и Object</a></h1>
<p>Библиотека Sanny Builder определяет статический класс <code>Object</code> для группировки команд, позволяющих создавать и управлять трехмерными объектами в игре. В то же время в JavaScript есть <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">собственный класс Object</a> со своими методами.</p>
<p>Чтобы не смешивать их, CLEO Redux использует класс <code>ScriptObject</code> вместо класса <code>Object</code> из библиотеки с <a href="https://library.sannybuilder.com/#/gta3/classes/Object">тем же интерфейсом</a>.</p>
<pre><code class="language-js">// код операции 0107, создает новый объект в игре
var x = ScriptObject.Create(modelId, x, y, z); 

// собственный код JavaScript, создает новый объект в памяти JS
var x = Object.create(null); 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-математических-объектов"><a class="header" href="#Использование-математических-объектов">Использование математических объектов</a></h2>
<p>В JavaScript есть встроенный объект <code>Math</code>, который обеспечивает общие математические операции, такие как <code>abs</code>, <code>sin</code>, <code>cos</code>, <code>random</code>, <code>pow</code>, <code>sqr</code> и т. д. CLEO Redux расширяет этот объект до включать дополнительные операции, поддерживаемые игрой. Интерфейс <code>Math</code> выглядит следующим образом:</p>
<pre><code class="language-ts">interface Math {
    // native code
    readonly E: number;
    readonly LN10: number;
    readonly LN2: number;
    readonly LOG2E: number;
    readonly LOG10E: number;
    readonly PI: number;
    readonly SQRT1_2: number;
    readonly SQRT2: number;
    abs(x: number): number;
    acos(x: number): number;
    asin(x: number): number;
    atan(x: number): number;
    atan2(y: number, x: number): number;
    ceil(x: number): number;
    cos(x: number): number;
    exp(x: number): number;
    floor(x: number): number;
    log(x: number): number;
    max(...values: number[]): number;
    min(...values: number[]): number;
    pow(x: number, y: number): number;
    random(): number;
    round(x: number): number;
    sin(x: number): number;
    sqrt(x: number): number;
    tan(x: number): number;

    // GTA III, GTA Vice City, GTA SA команды
    ConvertMetersToFeet(meters: int): int;
    RandomFloatInRange(min: float, max: float): float;
    RandomIntInRange(min: int, max: int): int;

    // GTA Vice City, GTA SA команды
    GetDistanceBetweenCoords2D(fromX: float, fromY: float, toX: float, toZ: float): float;
    GetDistanceBetweenCoords3D(fromX: float, fromY: float, fromZ: float, toX: float, toY: float, toZ: float): float;

    // GTA SA команды
    GetAngleBetween2DVectors(xVector1: float, yVector1: float, xVector2: float, yVector2: float): float;
    GetHeadingFromVector2D(_p1: float, _p2: float): float;
    LimitAngle(value: float): float;
}
</code></pre>
<p>Первая группа включает собственные константы и методы, предоставляемые средой выполнения JavaScript. Они начинаются со строчной буквы, например. <code>Math.abs</code>. Вы можете найти подробную документацию по этим методам <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">здесь</a>.</p>
<p>Затем идут специфичные для игры команды. Согласно соглашению об именах, каждый метод, привязанный к коду операции скрипта, начинается с заглавной буквы, например <code>Math.RandomIntInRange</code> (код операции 0209). Вы можете найти документацию в <a href="https://library.sannybuilder.com/">Sanny Builder Library</a>.</p>
<pre><code class="language-js">    var x = Math.abs(-1); // x = 1
    var f = Math.ConvertMetersToFeet(10) // f = 32
    var pi = Math.floor(Math.PI) // pi = 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Примечание. Это руководство предназначено для игр классической эпохи. Для получения информации об использовании класса Memory в Definitive Edition <a href="./using-memory-64.html">нажмите здесь</a>.</p>
<h2 id="Использование-объекта-памяти"><a class="header" href="#Использование-объекта-памяти">Использование объекта памяти</a></h2>
<p>Внутренний объект <code>Memory</code> предоставляет методы для доступа и управления данными или кодом в текущем процессе. Он имеет следующий интерфейс:</p>
<pre><code class="language-ts">interface Memory {
    ReadFloat(address: int, vp: boolean): float;
    WriteFloat(address: int, value: float, vp: boolean): void;
    ReadI8(address: int, vp: boolean): int;
    ReadI16(address: int, vp: boolean): int;
    ReadI32(address: int, vp: boolean): int;
    ReadU8(address: int, vp: boolean): int;
    ReadU16(address: int, vp: boolean): int;
    ReadU32(address: int, vp: boolean): int;
    WriteI8(address: int, value: int, vp: boolean): void;
    WriteI16(address: int, value: int, vp: boolean): void;
    WriteI32(address: int, value: int, vp: boolean): void;
    WriteU8(address: int, value: int, vp: boolean): void;
    WriteU16(address: int, value: int, vp: boolean): void;
    WriteU32(address: int, value: int, vp: boolean): void;
    Read(address: int, size: int, vp: boolean): int;
    Write(address: int, size: int, value: int, vp: boolean): void;

    ToFloat(value: int): float;
    FromFloat(value: float): int;
    ToU8(value: int): int;
    ToU16(value: int): int;
    ToU32(value: int): int;
    ToI8(value: int): int;
    ToI16(value: int): int;
    ToI32(value: int): int;

    Translate(symbol: string): int;

    CallFunction(address: int, numParams: int, pop: int, ...funcParams: int[]): void;
    CallFunctionReturn(address: int, numParams: int, pop: int, ...funcParams: int[]): int;
    CallMethod(address: int, struct: int, numParams: int, pop: int, ...funcParams: int[]): void;
    CallMethodReturn(address: int, struct: int, numParams: int, pop: int, ...funcParams: int[]): int;
    Fn: {
        Cdecl(address: int): (...funcParams: int[]) =&gt; int;
        CdeclFloat(address: int): (...funcParams: int[]) =&gt; float;
        CdeclI8(address: int): (...funcParams: int[]) =&gt; int;
        CdeclI16(address: int): (...funcParams: int[]) =&gt; int;
        CdeclI32(address: int): (...funcParams: int[]) =&gt; int;
        CdeclU8(address: int): (...funcParams: int[]) =&gt; int;
        CdeclU16(address: int): (...funcParams: int[]) =&gt; int;
        CdeclU32(address: int): (...funcParams: int[]) =&gt; int;

        Stdcall(address: int): (...funcParams: int[]) =&gt; int;
        StdcallFloat(address: int): (...funcParams: int[]) =&gt; float;
        StdcallI8(address: int): (...funcParams: int[]) =&gt; int;
        StdcallI16(address: int): (...funcParams: int[]) =&gt; int;
        StdcallI32(address: int): (...funcParams: int[]) =&gt; int;
        StdcallU8(address: int): (...funcParams: int[]) =&gt; int;
        StdcallU16(address: int): (...funcParams: int[]) =&gt; int;
        StdcallU32(address: int): (...funcParams: int[]) =&gt; int;

        Thiscall(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallFloat(address: int, struct: int): (...funcParams: int[]) =&gt; float;
        ThiscallI8(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallI16(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallI32(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallU8(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallU16(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallU32(address: int, struct: int): (...funcParams: int[]) =&gt; int;
    }
}
</code></pre>
<h3 id="Чтение-и-запись-значений"><a class="header" href="#Чтение-и-запись-значений">Чтение и запись значений</a></h3>
<p>Группа методов доступа к памяти (<code>ReadXXX</code>/<code>WriteXXX</code>) может использоваться для чтения или изменения значений, хранящихся в памяти. Каждый метод предназначен для определенного типа данных. Чтобы изменить значение с плавающей запятой (которое в исходной игре занимает 4 байта), используйте <code>Memory.WriteFloat</code>, например:</p>
<pre><code class="language-js">    Memory.WriteFloat(address, 1.0, false)
</code></pre>
<p>Где <code>address</code> — это переменная, хранящая адрес памяти, <code>1.0</code> — это значение для записи, а <code>false</code> означает, что нет необходимости изменять защиту памяти с помощью  <code>VirtualProtect</code> (адрес уже доступен для записи). </p>
<p>Точно так же, чтобы прочитать значение из памяти, используйте один из методов <code>ReadXXX</code>, в зависимости от того, какой тип данных содержит адрес памяти. Например, чтобы прочитать 8-битное целое число со знаком (также известное как <code>char</code> или <code>uint8</code>), используйте <code>Memory.ReadI8</code>, например:</p>
<pre><code class="language-js">    var x = Memory.ReadI8(address, true)
</code></pre>
<p>переменная <code>x</code> теперь содержит 8-битное целое значение в диапазоне (0..255). Чтобы показать возможные варианты, в этом примере в качестве последнего аргумента используется <code>true</code>, что означает, что атрибут защиты по умолчанию для этого адреса будет изменен на <code>PAGE_EXECUTE_READWRITE</code> перед чтением.</p>
<pre><code class="language-js">    var gravity = Memory.ReadFloat(gravityAddress, false);
    gravity += 0.05;
    Memory.WriteFloat(gravityAddress, gravity, false);
</code></pre>
<p>Наконец, последние два метода <code>Read</code> и <code>Write</code> — это то, что другие методы используют под капотом. Они имеют прямую привязку к опкодам <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A8D">0A8D READ_MEMORY</a> и <a href="https://library.sannybuilder.com/#/gta3/CLEO/0A8C">0A8C WRITE_MEMORY</a> и дают тот же результат. </p>
<p>Параметр <code>size</code> в методе <code>Read</code> может быть только <code>1</code>, <code>2</code> или <code>4</code>. CLEO обрабатывает <code>value</code> как целое число со знаком, хранящееся в формате с прямым порядком байтов.</p>
<p>В методе <code>Write</code> допускается любой <code>size</code> больше <code>0</code>. Размеры <code>3</code> и <code>5</code> и далее могут использоваться только вместе с одним байтом <code>value</code>. CLEO использует их для заполнения непрерывного блока памяти, начиная с <code>address</code>, с заданным <code>value</code> (подумайте об этом как о <code>memset</code> в C++).</p>
<pre><code class="language-js">    Memory.Write(addr, 0x90, 10, true) // &quot;noping&quot; 10 байт кода, начиная с адреса
</code></pre>
<p><strong>Обратите внимание, что для использования любого из методов чтения/записи требуется <code>mem</code> <a href="readme.html#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">разрешение</a></strong>.</p>
<h3 id="Метод-приведения-типов"><a class="header" href="#Метод-приведения-типов">Метод приведения типов</a></h3>
<p>По умолчанию методы <code>Read</code> и <code>Write</code> обрабатывают данные как целочисленные значения со знаком. Это может быть неудобно, если память содержит значение с плавающей запятой в формате IEEE 754 или большое 32-битное целое число со знаком (например, указатель). В этом случае используйте методы приведения <code>ToXXX</code>/<code>FromXXX</code>. Они действуют аналогично оператору <a href="https://docs.microsoft.com/en-us/cpp/cpp/reinterpret-cast-operator?view=msvc-160">reinterpret_cast</a> в C++.</p>
<p>Чтобы получить представление о том, чего ожидать от этих методов, см. следующие примеры:</p>
<pre><code class="language-js">    Memory.FromFloat(1.0) =&gt; 1065353216
    Memory.ToFloat(1065353216) =&gt; 1.0
    Memory.ToU8(-1) =&gt; 255
    Memory.ToU16(-1) =&gt; 65535
    Memory.ToU32(-1) =&gt; 4294967295
    Memory.ToI8(255) =&gt; -1
    Memory.ToI16(65535) =&gt; -1
    Memory.ToI32(4294967295) =&gt; -1
</code></pre>
<p>В качестве альтернативы используйте соответствующие методы для чтения/записи значения в виде числа с плавающей запятой (<code>ReadFloat</code>/<code>WriteFloat</code>) или целого числа без знака (<code>ReadUXXX</code>/<code>WriteUXXX</code>).</p>
<h3 id="Вызов-внешних-функций"><a class="header" href="#Вызов-внешних-функций">Вызов внешних функций</a></h3>
<p>Объект <code>Memory</code> позволяет вызвать чужую (собственную) функцию по ее адресу одним из следующих способов:</p>
<ul>
<li><code>Memory.CallFunction</code> - привязывается к <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA5">0AA5 CALL_FUNCTION</a></li>
<li><code>Memory.CallFunctionReturn</code> - привязывается к <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA7">0AA7 CALL_FUNCTION_RETURN</a></li>
<li><code>Memory.CallMethod</code> - привязывается к <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA6">CALL_METHOD</a></li>
<li><code>Memory.CallMethodReturn</code> - привязывается к <a href="https://library.sannybuilder.com/#/gta3/CLEO/0AA8">CALL_METHOD_RETURN</a></li>
</ul>
<pre><code class="language-js">    Memory.CallFunction(0x1234567, 2, 0, 1000, 2000)
</code></pre>
<p>Где <code>0x1234567</code> — адрес функции, <code>2</code> — количество аргументов, <code>0</code> — параметр <code>pop</code> (см. ниже), <code>1000</code> и <code>2000</code> — два аргумента, переданных в функцию.</p>
<p>Обратите внимание, что устаревшая реализация команд вызова SCM требует, чтобы аргументы вызываемой функции были перечислены в обратном порядке. Вот и все, вы увидите тот же вызов в SCM, что и:</p>
<pre><code>0AA5: call 0x1234567 num_params 2 pop 0 2000 1000
</code></pre>
<p>Где <code>2000</code> — второй аргумент, передаваемый функции, расположенной по адресу 0x1234567, а <code>1000</code> — первый.</p>
<p>Третий параметр (<code>pop</code>) в <code>Memory.CallFunction</code> определяет соглашение о вызовах. Если установлено значение <code>0</code>, функция вызывается с использованием соглашения <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall">stdcall</a>. Когда для него установлено то же значение, что и для <code>numParam</code>, функция вызывается с использованием соглашения <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a>. Любое другое значение нарушает код.</p>
<p><code>Memory.CallFunctionReturn</code> имеет тот же интерфейс, но дополнительно записывает результат функции в переменную.</p>
<p><code>Memory.CallMethod</code> вызывает метод объекта:</p>
<pre><code class="language-js">    Memory.CallMethod(0x2345678, 0x7001234, 2, 0, 1000, 2000)
</code></pre>
<p>Второй параметр (<code>0x7001234</code>) — это адрес объекта. Параметр <code>pop</code> всегда равен <code>0</code> (метод использует соглашение <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall">thiscall</a>).</p>
<p>Чтобы вызвать метод и получить от него результат, используйте <code>Memory.CallMethodReturn</code>.</p>
<p>Обратите внимание, что все аргументы читаются как 32-битные целые числа со знаком. Если вам нужно предоставить аргумент типа float, используйте <code>Memory.FromFloat</code>, например:</p>
<pre><code class="language-js">    Memory.CallFunction(0x1234567, 1, 1, Memory.FromFloat(123.456))
</code></pre>
<p>CLEO Redux поддерживает вызов сторонних функций с параметрами до 16.</p>
<p><strong>Обратите внимание, что для использования любого из методов вызова требуется <code>mem</code> <a href="readme.html#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">разрешение</a></strong>.</p>
<h4 id="Удобные-методы-с-объектом-fn"><a class="header" href="#Удобные-методы-с-объектом-fn">Удобные методы с объектом Fn</a></h4>
<p><code>Memory.Fn</code> предоставляет множество удобных методов для вызова различных типов внешних функций.</p>
<pre><code class="language-ts">Fn: {
        Cdecl(address: int): (...funcParams: int[]) =&gt; int;
        CdeclFloat(address: int): (...funcParams: int[]) =&gt; float;
        CdeclI8(address: int): (...funcParams: int[]) =&gt; int;
        CdeclI16(address: int): (...funcParams: int[]) =&gt; int;
        CdeclI32(address: int): (...funcParams: int[]) =&gt; int;
        CdeclU8(address: int): (...funcParams: int[]) =&gt; int;
        CdeclU16(address: int): (...funcParams: int[]) =&gt; int;
        CdeclU32(address: int): (...funcParams: int[]) =&gt; int;

        Stdcall(address: int): (...funcParams: int[]) =&gt; int;
        StdcallFloat(address: int): (...funcParams: int[]) =&gt; float;
        StdcallI8(address: int): (...funcParams: int[]) =&gt; int;
        StdcallI16(address: int): (...funcParams: int[]) =&gt; int;
        StdcallI32(address: int): (...funcParams: int[]) =&gt; int;
        StdcallU8(address: int): (...funcParams: int[]) =&gt; int;
        StdcallU16(address: int): (...funcParams: int[]) =&gt; int;
        StdcallU32(address: int): (...funcParams: int[]) =&gt; int;

        Thiscall(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallFloat(address: int, struct: int): (...funcParams: int[]) =&gt; float;
        ThiscallI8(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallI16(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallI32(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallU8(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallU16(address: int, struct: int): (...funcParams: int[]) =&gt; int;
        ThiscallU32(address: int, struct: int): (...funcParams: int[]) =&gt; int;
    }
</code></pre>
<p>Эти методы предназначены для охвата всех возможных сигнатур функций. Например, этот код:</p>
<pre><code class="language-js">    Memory.CallMethod(0x2345678, 0x7001234, 2, 0, 1000, 2000)
</code></pre>
<p>Также можно записать как:</p>
<pre><code class="language-js">    Memory.Fn.Thiscall(0x2345678, 0x7001234)(1000, 2000)
</code></pre>
<p>Обратите внимание на несколько ключевых отличий. Прежде всего, методы <code>Memory.Fn</code> не вызывают внешнюю функцию напрямую. Вместо этого они возвращают новую функцию JavaScript, которую можно сохранить в переменной и повторно использовать для многократного вызова связанной внешней функции с разными аргументами:</p>
<pre><code class="language-js">    var myMethod = Memory.Fn.Thiscall(0x2345678, 0x7001234);
    myMethod(1000, 2000); // вызывает метод 0x2345678 с аргументами 1000 и 2000
    myMethod(3000, 5000); // вызывает метод 0x2345678 с аргументами 3000 и 5000
</code></pre>
<p>Второе отличие состоит в том, что отсутствуют параметры <code>numParams</code> и <code>pop</code>. Каждый метод <code>Fn</code> вычисляет их автоматически.</p>
<p>По умолчанию возвращаемый результат считается 32-битным целым числом со знаком. Если функция возвращает другой тип (значение с плавающей запятой или целое число со знаком), используйте один из методов, соответствующих сигнатуре функции, например:</p>
<pre><code class="language-js">    var flag = Memory.Fn.CdeclU8(0x1234567)()
</code></pre>
<p>Этот код вызывает функцию <code>cdecl</code> по адресу <code>0x1234567</code> без аргументов и сохраняет результат в виде 8-битного целого числа без знака. </p>
<h3 id="Поиск-адресов-памяти-в-re3-и-revc"><a class="header" href="#Поиск-адресов-памяти-в-re3-и-revc">Поиск адресов памяти в re3 и reVC</a></h3>
<p>Поскольку <code>re3</code> и <code>reVC</code> используют функцию рандомизации адресного пространства (ASLR), может быть трудно найти нужные адреса. CLEO Redux предоставляет вспомогательную функцию <code>Memory.Translate</code> которая принимает имя функции или переменной и возвращает ее текущий адрес. Если запрошенный символ не найден, результат равен 0.</p>
<pre><code class="language-js">    var addr = Memory.Translate(&quot;CTheScripts::MainScriptSize&quot;);

    // проверить, не равен ли адрес нулю
    if (addr) {
        showTextBox(&quot;MainScriptSize = &quot; + Memory.ReadI32(addr, 0))
    }
</code></pre>
<p>На данный момент <code>Memory.Translate</code> следует использовать только в <code>re3</code> и <code>reVC</code>. В других играх в большинстве случаев вы будете получать <code>0</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Примечание. Это руководство предназначено для обновленных игр, работающих как 64-разрядные приложения. Для получения информации об использовании класса Memory в играх классической эпохи <a href="./using-memory.html">нажмите здесь</a>.</p>
<h2 id="Использование-объекта-памяти-1"><a class="header" href="#Использование-объекта-памяти-1">Использование объекта памяти</a></h2>
<p>Внутренний объект <code>Memory</code> предоставляет методы для доступа и управления данными или кодом в текущем процессе. Он имеет следующий интерфейс:</p>
<pre><code class="language-ts">interface Memory {
    ReadFloat(address: int, vp: boolean, ib: boolean): float;
    WriteFloat(address: int, value: float, vp: boolean, ib: boolean): void;
    ReadI8(address: int, vp: boolean, ib: boolean): int;
    ReadI16(address: int, vp: boolean, ib: boolean): int;
    ReadI32(address: int, vp: boolean, ib: boolean): int;
    ReadU8(address: int, vp: boolean, ib: boolean): int;
    ReadU16(address: int, vp: boolean, ib: boolean): int;
    ReadU32(address: int, vp: boolean, ib: boolean): int;
    WriteI8(address: int, value: int, vp: boolean, ib: boolean): void;
    WriteI16(address: int, value: int, vp: boolean, ib: boolean): void;
    WriteI32(address: int, value: int, vp: boolean, ib: boolean): void;
    WriteU8(address: int, value: int, vp: boolean, ib: boolean): void;
    WriteU16(address: int, value: int, vp: boolean, ib: boolean): void;
    WriteU32(address: int, value: int, vp: boolean, ib: boolean): void;
    Read(address: int, size: int, vp: boolean, ib: boolean): int;
    Write(address: int, size: int, value: int, vp: boolean, ib: boolean): void;

    ToFloat(value: int): float;
    FromFloat(value: float): int;
    ToU8(value: int): int;
    ToU16(value: int): int;
    ToU32(value: int): int;
    ToI8(value: int): int;
    ToI16(value: int): int;
    ToI32(value: int): int;

    CallFunction(address: int, ib: boolean, numParams: int, ...funcParams: int[]): void;
    CallFunctionReturn(address: int, ib: boolean, numParams: int, ...funcParams: int[]): int;
    CallFunctionReturnFloat(address: int, ib: boolean, numParams: int, ...funcParams: int[]): float;

    Fn: {
        X64(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64Float(address: int, ib: boolean): (...funcParams: int[]) =&gt; float;
        X64I8(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64I16(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64I32(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64U8(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64U16(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64U32(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
    }
}
</code></pre>
<h3 id="Чтение-и-запись-значений-1"><a class="header" href="#Чтение-и-запись-значений-1">Чтение и запись значений</a></h3>
<p>Группа методов доступа к памяти (<code>ReadXXX</code>/<code>WriteXXX</code>) может использоваться для чтения или изменения значений, хранящихся в памяти. Каждый метод предназначен для определенного типа данных. Чтобы изменить значение с плавающей запятой (которое в исходной игре занимает 4 байта), используйте <code>Memory.WriteFloat</code>, например:</p>
<pre><code class="language-js">    Memory.WriteFloat(address, 1.0, false, false)
</code></pre>
<p>Где <code>address</code> — это переменная, хранящая адрес памяти, <code>1.0</code> — это значение для записи, первое «false» означает, что нет необходимости изменять защиту памяти с помощью <code>VirtualProtect</code> (адрес уже доступен для записи). Второй <code>false</code> — это значение флага <code>ib</code>, который предписывает CLEO рассматривать <code>address</code> либо как абсолютный адрес (<code>ib</code> = <code>false</code>), либо как относительное смещение к текущему базовому адресу образа (<code>ib</code> = <code>true</code>). Поскольку в окончательных версиях используется функция ASLR, их абсолютные адреса памяти меняются при запуске игры из-за изменения начального адреса. Рассмотрим следующий пример:</p>
<pre><code>0x1400000000 ImageBase
...
...
0x1400000020 SomeValue
</code></pre>
<p>Вы хотите изменить <code>SomeValue</code>, которое в настоящее время находится по адресу <code>0x1400000020</code>. Вы можете сделать это с помощью <code>Memory.Write(0x1400000020, 1, 1, false, false)</code>. Однако при следующем запуске игры расположение памяти может выглядеть так:</p>
<pre><code>0x1500000000 ImageBase
...
...
0x1500000020 SomeValue
</code></pre>
<p>Эффективно ломая сценарий. В этом случае рассчитайте относительное смещение от базы изображения (<code>0x1500000020</code> - <code>0x1500000000</code> = <code>0x20</code>), которое будет постоянным для конкретной версии игры. Используйте Memory.Write следующим образом: <code>Memory.Write(0x20, 1, 1, false, true)</code>. CLEO суммирует смещение (<code>0x20</code>) с текущим значением базы изображения (<code>0x1400000000</code>, <code>0x1500000000</code> и т. д.) и записывает по правильному абсолютному адресу.</p>
<p>Для вашего удобства вы можете узнать текущее значение базы образа в <code>cleo_redux.log</code>, например:</p>
<pre><code>09:27:35 [INFO] Image base address 0x7ff7d1f50000
</code></pre>
<p>Точно так же, чтобы прочитать значение из памяти, используйте один из методов <code>ReadXXX</code>, в зависимости от того, какой тип данных содержит адрес памяти. Например, чтобы прочитать 8-битное целое число со знаком (также известное как <code>char</code> или <code>uint8</code>), используйте <code>Memory.ReadI8</code>, например:</p>
<pre><code class="language-js">    var x = Memory.ReadI8(offset, true, true)
</code></pre>
<p>Переменная <code>x</code> теперь содержит 8-битное целое число в диапазоне (0..255). Чтобы показать возможные варианты, в этом примере в качестве последнего аргумента используется <code>true</code>, что означает, что атрибут защиты по умолчанию для этого адреса будет изменен на <code>PAGE_EXECUTE_READWRITE</code> перед чтением.</p>
<pre><code class="language-js">    var gravity = Memory.ReadFloat(gravityOffset, false, true);
    gravity += 0.05;
    Memory.WriteFloat(gravityOffset, gravity, false, true);
</code></pre>
<p>Наконец, последние два метода <code>Read</code> и <code>Write</code> — это то, что другие методы используют под капотом. Они имеют прямую привязку к коду Rust, который читает и записывает память. В коде JavaScript вы можете использовать входные аргументы размером до 53-битных чисел.</p>
<p>Параметр <code>size</code> в методе <code>Read</code> может быть только <code>1</code>, <code>2</code>, <code>4</code> или <code>8. CLEO обрабатывает </code>value` как целое число со знаком, хранящееся в формате с прямым порядком байтов. </p>
<p>В методе <code>Write</code> допускается любой <code>size</code> больше <code>0</code>. Размеры «<code>3</code>, <code>5</code>, <code>6</code>, <code>7</code> и <code>9</code> и далее могут использоваться только вместе с одним байтом <code>value</code>. CLEO использует их для заполнения непрерывного блока памяти, начиная с <code>address</code>, заданным <code>value</code> (подумайте об этом как о <code>memset</code> в C++).</p>
<pre><code class="language-js">    Memory.Write(offset, 0x90, 10, true, true) // &quot;noping&quot; 10 байт кода, начиная с базы смещения+изображения
</code></pre>
<p><strong>Обратите внимание, что для использования любого из методов чтения/записи требуется <code>mem</code> <a href="readme.html#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">разрешение</a></strong>.</p>
<h3 id="Метод-приведения-типов-1"><a class="header" href="#Метод-приведения-типов-1">Метод приведения типов</a></h3>
<p>По умолчанию методы <code>Read</code> и <code>Write</code> обрабатывают данные как целочисленные значения со знаком. Это может быть неудобно, если память содержит значение с плавающей запятой в формате IEEE 754 или большое 32-битное целое число со знаком (например, указатель). В этом случае используйте методы приведения <code>ToXXX</code>/<code>FromXXX</code>. Они действуют аналогично оператору <a href="https://docs.microsoft.com/en-us/cpp/cpp/reinterpret-cast-operator?view=msvc-160">reinterpret_cast</a> в C++.</p>
<p>Чтобы получить представление о том, чего ожидать от этих методов, см. следующие примеры:</p>
<pre><code class="language-js">    Memory.FromFloat(1.0) =&gt; 1065353216
    Memory.ToFloat(1065353216) =&gt; 1.0
    Memory.ToU8(-1) =&gt; 255
    Memory.ToU16(-1) =&gt; 65535
    Memory.ToU32(-1) =&gt; 4294967295
    Memory.ToI8(255) =&gt; -1
    Memory.ToI16(65535) =&gt; -1
    Memory.ToI32(4294967295) =&gt; -1
</code></pre>
<p>В качестве альтернативы используйте соответствующие методы для чтения/записи значения в виде числа с плавающей запятой (<code>ReadFloat</code>/<code>WriteFloat</code>) или целого числа без знака (<code>ReadUCX</code>/<code>WriteUXXX</code>).</p>
<h3 id="Вызов-внешних-функций-1"><a class="header" href="#Вызов-внешних-функций-1">Вызов внешних функций</a></h3>
<p>Объект <code>Memory</code> позволяет вызвать чужую (собственную) функцию по ее адресу одним из следующих способов:</p>
<ul>
<li><code>Memory.CallFunction</code></li>
<li><code>Memory.CallFunctionReturn</code></li>
<li><code>Memory.CallFunctionReturnFloat</code></li>
</ul>
<pre><code class="language-js">    Memory.CallFunction(0xEFFB30, true, 1, 13)
</code></pre>
<p>Где <code>0xEFFB30</code> — это смещение функции относительно IMAGE BASE (представьте себе, что это случайный начальный адрес игровой памяти), <code>true</code> — это флаг <code>ib</code> (см. ниже), <code>1</code> – количество входных аргументов, и <code>13</code> — единственный аргумент, передаваемый в функцию.</p>
<p>Параметр <code>ib</code> в <code>Memory.CallFunction</code> имеет то же значение, что и в командах чтения/записи памяти. При значении <code>true</code> CLEO добавляет текущий известный адрес базы образа к значению, указанному в качестве первого аргумента, для вычисления абсолютного адреса памяти функции. Если установлено значение <code>false</code>, первый аргумент не изменяется.</p>
<p>Чтобы передать функции значения с плавающей запятой, преобразуйте значение в целое число, используя <code>Memory.FromFloat</code>:</p>
<pre><code class="language-js">    Memory.CallFunction(0x1234567, true, 1, Memory.FromFloat(123.456));
</code></pre>
<p>Возвращаемое значение функции, вызванной с помощью <code>Memory.CallFunction</code>, игнорируется. Чтобы прочитать результат, используйте <code>Memory.CallFunctionReturn</code> с теми же параметрами. Используйте <code>Memory.CallFunctionReturnFloat</code> для вызова функции, которая возвращает значение с плавающей запятой.</p>
<p>CLEO Redux поддерживает вызов сторонних функций с параметрами до 16.</p>
<p><strong>Обратите внимание, что для использования любого из методов вызова требуется <code>mem</code> <a href="readme.html#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">разрешение</a></strong>.</p>
<h4 id="Удобные-методы-с-объектом-fn-1"><a class="header" href="#Удобные-методы-с-объектом-fn-1">Удобные методы с объектом Fn</a></h4>
<p><code>Memory.Fn</code> предоставляет удобные методы для вызова различных типов внешних функций.</p>
<pre><code class="language-ts">    Fn: {
        X64(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64Float(address: int, ib: boolean): (...funcParams: int[]) =&gt; float;
        X64I8(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64I16(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64I32(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64U8(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64U16(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
        X64U32(address: int, ib: boolean): (...funcParams: int[]) =&gt; int;
    }
</code></pre>
<p>Эти методы предназначены для охвата всех поддерживаемых типов возврата. Например, этот код:</p>
<pre><code class="language-js">    Memory.CallFunction(0xEFFB30, true, 1, 13)
</code></pre>
<p>Также можно записать как:</p>
<pre><code class="language-js">    Memory.Fn.X64(0xEFFB30, true)(13)
</code></pre>
<p>Обратите внимание на несколько ключевых отличий. Прежде всего, методы <code>Memory.Fn</code> не вызывают внешнюю функцию напрямую. Вместо этого они возвращают новую функцию JavaScript, которую можно сохранить в переменной и повторно использовать для многократного вызова связанной внешней функции с разными аргументами:</p>
<pre><code class="language-js">    var f = Memory.Fn.X64(0xEFFB30, true);
    f(13) // вызывает функцию 0xEFFB30 с аргументом 13
    f(11) // вызывает метод 0xEFFB30 с аргументом 11
</code></pre>
<p>Второе отличие состоит в том, что здесь нет параметра <code>numParams</code>. Каждый метод <code>Fn</code> вычисляет это автоматически.</p>
<p>По умолчанию возвращаемый результат считается 64-битным целым числом со знаком. Если функция возвращает другой тип (например, логическое значение), используйте один из методов, соответствующих сигнатуре функции:</p>
<pre><code class="language-js">    var flag = Memory.Fn.X64U8(0x1234567, true)()
</code></pre>
<p>Этот код вызывает функцию по адресу <code>0x1234567</code> + IMAGE_BASE без аргументов и сохраняет результат как 8-битное целое число без знака.</p>
<pre><code class="language-js">    var float = Memory.Fn.X64Float(0x456789, true)()
</code></pre>
<p>Этот код вызывает функцию по адресу <code>0x456789</code> + IMAGE_BASE без аргументов и сохраняет результат как значение с плавающей запятой.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Устаревшие"><a class="header" href="#Устаревшие">Устаревшие</a></h1>
<p>Использование следующих команд не рекомендуется.</p>
<h1 id="op"><a class="header" href="#op">op</a></h1>
<p><code>op(opcode_id, ...input_args)</code> - низкоуровневая функция для выполнения любой внутриигровой команды с опкодом <code>{opcode_id}</code>.</p>
<pre><code>Для команд, возвращающих одно значение, результатом является это значение.

Для команд, возвращающих несколько значений, результатом является объект, в котором каждый ключ соответствует возвращаемому значению. Имена ключей соответствуют именам выходов, указанным в определении команды.

Для условных команд результатом является логическое значение `true` или `false`.
</code></pre>
<pre><code class="language-js">op(0x00c0, 12, 30); // устанавливаем время суток на 12:30
</code></pre>
<pre><code class="language-js">var pos = op(0x0054, 0); // возвращает вектор координат игрока 0 {x, y, z}
showTextBox(&quot;Player pos:&quot;, &quot; x = &quot;, pos.x, &quot; y = &quot;, pos.y, &quot; z = &quot;, pos.z);
</code></pre>
<pre><code class="language-js">if (op(0x0248, 101)) {
  // Проверяем условие.
  showTextBox(&quot;Model with id 101 has been loaded&quot;);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Решение-проблем"><a class="header" href="#Решение-проблем">Решение проблем</a></h1>
<h2 id="Если-cleo-не-работает-с-re3-или-revc"><a class="header" href="#Если-cleo-не-работает-с-re3-или-revc">Если CLEO не работает с re3 или reVC</a></h2>
<p>CLEO Redux поддерживает только «Windows D3D9 MSS 32bit» версию <code>re3</code> или <code>reVC</code>.</p>
<p>При запуске на <code>re3</code> и <code>reVC</code> убедитесь, что в каталоге игры есть файл <code>re3.pdb</code> (для <strong>re3</strong>) или <code>reVC.pdb</code> (для <strong>reVC</strong>). Из-за динамического характера адресов памяти в этих реализациях CLEO Redux использует отладочную информацию, хранящуюся в файле PDB, для правильного определения своего местоположения.</p>
<h2 id="Если-cleo-крашит-san-andreas-the-definitive-edition"><a class="header" href="#Если-cleo-крашит-san-andreas-the-definitive-edition">Если CLEO крашит San Andreas: The Definitive Edition</a></h2>
<ul>
<li>Убедитесь, что вы установили 64-битную версию Ultimate ASI Loader (<a href="https://github.com/ThirteenAG/Ultimate-ASI-Loader/releases/download/x64-latest/version.zip">прямая ссылка на последний релиз</a>).
<ul>
<li>Поместите <code>version.dll</code> в <code>GTA San Andreas - Definitive Edition\Gameface\Binaries\Win64</code></li>
</ul>
</li>
<li>убедитесь, что у вас установлена последняя версия CLEO Redux (0.8.2 и выше)</li>
<li>удалить файлы конфигурации из <code>Documents\Rockstar Games\GTA San Andreas Definitive Edition\Config\WindowsNoEditor</code></li>
<li>запустить игру (или Rockstar Games Launcher) от имени администратора</li>
</ul>
<p>Если CLEO не может создавать файлы в <code>GTA San Andreas - Definitive Edition\Gameface\Binaries\Win64</code>, он будет использовать другой каталог в <code>C:\Users\&lt;ваше_имя&gt;\AppData\Roaming\CLEO Redux</code>. Там должен быть <code>cleo_redux.log</code> и папка CLEO, куда попадают все ваши скрипты.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Лог"><a class="header" href="#Лог">Лог</a></h1>
<p>CLEO регистрирует важные события и ошибки в файле <code>cleo_redux.log</code> расположенном в папке с игрой (или <code>C:\Users\&lt;ваше_имя_пользователя&gt;\AppData\Roaming\CLEO Redux</code>, см. <a href="log.html#%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D1%87%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0">Первичная настройка</a> примечание). Этот файл перезаписывается при каждом запуске игры. Если у вас возникнут какие-либо проблемы при использовании CLEO Redux, начните исследовать основную причину с этого файла.</p>
<p>Чтобы транслировать события в вашем терминале во время тестирования скрипта, запустите:</p>
<pre><code>tail -f cleo_redux.log
</code></pre>
<p><code>tail</code> - это команда unix, поэтому необходима совместимая среда (например, Git Bash).</p>
<div style="break-before: page; page-break-before: always;"></div><p>Здесь вы можете найти ответы на часто задаваемые вопросы о поддержке ремастера The Trilogy.</p>
<ul>
<li><a href="the-definitive-edition-faq.html#%D0%9A%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D1%8E%D1%82%D1%81%D1%8F">Какие версии поддерживаются?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9A%D0%B0%D0%BA-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C-cleo-redux-%D0%B2-the-definitive-edition">Как установить CLEO Redux в The Definitive Edition?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%A7%D1%82%D0%BE-%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D0%B5%D1%81%D0%BB%D0%B8-%D1%8F-%D0%BD%D0%B5-%D0%BC%D0%BE%D0%B3%D1%83-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3-cleo">Что делать, если я не могу найти каталог CLEO?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9A%D0%B0%D0%BA-%D1%83%D0%B4%D0%B0%D0%BB%D0%B8%D1%82%D1%8C-cleo-redux">Как удалить CLEO Redux?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%95%D1%81%D1%82%D1%8C-%D0%BB%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BE%D1%82-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D0%B8%D0%B3%D1%80">Есть ли отличия от поддержки классических игр?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9C%D0%BE%D0%B3%D1%83-%D0%BB%D0%B8-%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D1%80%D0%B8%D0%B3%D0%B8%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%BA%D0%BE%D0%B4%D1%8B">Могу ли я использовать оригинальные опкоды?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9A%D0%B0%D0%BA-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B2-javascript">Как узнать, какие команды можно использовать в JavaScript?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9C%D0%BE%D0%B3%D1%83-%D0%BB%D0%B8-%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D0%BF%D0%BA%D0%BE%D0%B4%D1%8B-cleo">Могу ли я использовать опкоды CLEO?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9C%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%82%D1%8C-%D1%81-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E-%D0%B8%D0%B3%D1%80%D1%8B-%D0%B8%D0%BB%D0%B8-%D0%B2%D1%8B%D0%B7%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%B8%D0%B3%D1%80%D1%8B">Можно ли работать с памятью игры или вызывать функции игры?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%9A%D0%B0%D0%BA-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-cleo-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-sanny-builder">Как компилировать CLEO-скрипты с помощью Sanny Builder?</a></li>
<li><a href="the-definitive-edition-faq.html#%D0%AF-%D0%BD%D0%B5-%D0%BC%D0%BE%D0%B3%D1%83-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D0%B7%D0%B4%D0%B5%D1%81%D1%8C-%D0%BE%D1%82%D0%B2%D0%B5%D1%82-%D0%BD%D0%B0-%D1%81%D0%B2%D0%BE%D0%B9-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%BA%D1%83%D0%B4%D0%B0-%D0%BC%D0%BD%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%B8%D1%82%D1%8C%D1%81%D1%8F">Я не могу найти здесь ответ на свой вопрос, куда мне обратиться?</a></li>
</ul>
<h3 id="Какие-версии-поддерживаются"><a class="header" href="#Какие-версии-поддерживаются">Какие версии поддерживаются?</a></h3>
<ul>
<li>GTA III: The Definitive Edition <strong>1.0.0.14718</strong> (Title Update 1.03), <strong>1.0.0.15284</strong> (Title Update 1.04)</li>
<li>GTA Vice City: The Definitive Edition <strong>1.0.0.14718</strong> (Title Update 1.03), <strong>1.0.0.15399</strong> (Title Update 1.04)</li>
<li>San Andreas: The Definitive Edition <strong>1.0.0.14296</strong>, <strong>1.0.0.14388</strong>, <strong>1.0.0.14718</strong> (Title Update 1.03), <strong>1.0.0.15483</strong> (Title Update 1.04)</li>
</ul>
<h3 id="Как-установить-cleo-redux-в-the-definitive-edition"><a class="header" href="#Как-установить-cleo-redux-в-the-definitive-edition">Как установить CLEO Redux в The Definitive Edition?</a></h3>
<ul>
<li>
<p>Загрузите и установите <a href="https://github.com/ThirteenAG/Ultimate-ASI-Loader/releases/download/x64-latest/version.zip">Ultimate ASI Loader x64</a> от <a href="https://github.com/ThirteenAG">ThirteenAG</a> (поместите <code>version.dll</code> в каталог <code>Gameface\Binaries\Win64</code>).</p>
</li>
<li>
<p>Скопируйте <code>cleo_redux64.asi</code> в тот же каталог.</p>
</li>
<li>
<p>Запустите игру один раз, и вы должны создать новый каталог CLEO в том же каталоге. Если этого не произошло, проверьте ниже.</p>
</li>
</ul>
<h3 id="Что-делать-если-я-не-могу-найти-каталог-cleo"><a class="header" href="#Что-делать-если-я-не-могу-найти-каталог-cleo">Что делать, если я не могу найти каталог CLEO?</a></h3>
<p>У многих людей запуск игры с установленным CLEO Redux приводит к немедленному вылету. Это происходит, если в текущем каталоге (<code>Win64</code>) нет прав на запись. Чтобы исправить эту проблему, CLEO использует альтернативный путь в <code>C:\Users\&lt;Ваше_имя_пользователя&gt;\AppData\Roaming\CLEO Redux</code>. Там можно найти <code>cleo_redux.log</code> и каталог <code>CLEO</code>. См. также <a href="troubleshooting.html">руководство по устранению неполадок</a>.</p>
<h3 id="Как-удалить-cleo-redux"><a class="header" href="#Как-удалить-cleo-redux">Как удалить CLEO Redux?</a></h3>
<ul>
<li>Удалите <code>cleo_redux64.asi</code>.</li>
<li>Удалите папку <code>CLEO</code> (необязательно).</li>
<li>Удалите <code>cleo_redux.log</code> (необязательно)</li>
</ul>
<h3 id="Есть-ли-отличия-от-поддержки-классических-игр"><a class="header" href="#Есть-ли-отличия-от-поддержки-классических-игр">Есть ли отличия от поддержки классических игр?</a></h3>
<p>Есть. CLEO не отображает версию в меню игры. Также CLEO может запускать только JS-скрипты в GTA III и GTA VC. В San Andreas поддерживаются как скрипты CS, так и JS.</p>
<h3 id="Могу-ли-я-использовать-оригинальные-опкоды"><a class="header" href="#Могу-ли-я-использовать-оригинальные-опкоды">Могу ли я использовать оригинальные опкоды?</a></h3>
<p>Да, ты можешь. Обратитесь к Sanny Builder Library: https://library.sannybuilder.com/#/sa_unreal. Обратите внимание, что некоторые коды операций были изменены по сравнению с классическими играми, поэтому не ожидайте, что все будет работать так же, как в классических играх. Если вы столкнулись с проблемой, найдите помощь в <a href="https://discord.gg/d5dZSfgBZr">нашем Discord</a>.</p>
<h3 id="Как-узнать-какие-команды-можно-использовать-в-javascript"><a class="header" href="#Как-узнать-какие-команды-можно-использовать-в-javascript">Как узнать, какие команды можно использовать в JavaScript?</a></h3>
<p>После каждого запуска игры CLEO создает файл d.ts в каталоге CLEO.config. Он называется gta3.d.ts, vc.d.ts или sa.d.ts в зависимости от игры. В этом файле перечислены все поддерживаемые функции и методы, которые вы можете использовать в коде JavaScript.</p>
<p>Чтобы включить автозаполнение в VS Code, включите в свой JS-скрипт следующую строку:</p>
<pre><code class="language-js">/// &lt;reference path=&quot;.config/sa.d.ts&quot; /&gt;
</code></pre>
<p>Обновите имя файла соответственно в зависимости от того, для какой игры предназначен ваш скрипт.</p>
<h3 id="Могу-ли-я-использовать-опкоды-cleo"><a class="header" href="#Могу-ли-я-использовать-опкоды-cleo">Могу ли я использовать опкоды CLEO?</a></h3>
<p>Опкоды из библиотеки CLEO (CLEO 4 или CLEO для GTA III и Vice City) не поддерживаются. Но CLEO Redux добавляет свои новые опкоды для некоторых операций.</p>
<ul>
<li>0C00 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C00">IS_KEY_PRESSED</a></li>
<li>0C01 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C01">INT_ADD</a></li>
<li>0C02 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C02">INT_SUB</a></li>
<li>0C03 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C03">INT_MUL</a></li>
<li>0C04 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C04">INT_DIV</a></li>
<li>0C05 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C05">TERMINATE_THIS_CUSTOM_SCRIPT</a></li>
<li>0C06 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C06">WRITE_MEMORY</a> (<strong>UNSAFE</strong> - требует <code>mem</code> разрешение)</li>
<li>0C07 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C07">READ_MEMORY</a> (<strong>UNSAFE</strong> - требует <code>mem</code> разрешение)</li>
<li>0C08 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C08">CALL_FUNCTION</a> (<strong>UNSAFE</strong> - требует <code>mem</code> разрешение)</li>
<li>0C09 <a href="https://library.sannybuilder.com/#/sa_unreal/CLEO/0C09">CALL_FUNCTION_RETURN</a> (<strong>UNSAFE</strong> - требует <code>mem</code> разрешение)</li>
</ul>
<p>Обратите внимание, что Sanny Builder еще не поддерживает эти новые коды операций «из коробки». Чтобы включить новые коды операций в ваших сценариях CS, добавьте следующие строки поверх вашего сценария:</p>
<pre><code>{$O 0C00=1,  is_key_pressed %1d% }
{$O 0C01=3,%3d% = %1d% + %2d% }
{$O 0C02=3,%3d% = %1d% - %2d% }
{$O 0C03=3,%3d% = %1d% * %2d% }
{$O 0C04=3,%3d% = %1d% / %2d% }
{$O 0C05=0,terminate_this_custom_script }
{$O 0C06=5,write_memory %1d% size %2d% value %3d% virtual_protect %4d% ib %5d% }
{$O 0C07=5,%5d% = read_memory %1d% size %2d% virtual_protect %3d% ib %4d% }
{$O 0C08=-1,call_function %1d% ib %2d% num_params %3d%}
{$O 0C09=-1,call_function_return %1d% ib %2d% num_params %3d%}
</code></pre>
<h3 id="Можно-ли-работать-с-памятью-игры-или-вызывать-функции-игры"><a class="header" href="#Можно-ли-работать-с-памятью-игры-или-вызывать-функции-игры">Можно ли работать с памятью игры или вызывать функции игры?</a></h3>
<p>Да, проверьте <a href="using-memory-64.html">Руководство по использованию памяти</a>.</p>
<h3 id="Как-компилировать-cleo-скрипты-с-помощью-sanny-builder"><a class="header" href="#Как-компилировать-cleo-скрипты-с-помощью-sanny-builder">Как компилировать CLEO-скрипты с помощью Sanny Builder?</a></h3>
<p>Используйте режим SA Mobile для компиляции CLEO-скриптов для San Andreas: The Definitive Edition. Обратите внимание, что CLEO Redux не поддерживает CS-скрипты в GTA III: DE и VC: DE. JS-скрипты поддерживаются во всех играх.</p>
<h3 id="Я-не-могу-найти-здесь-ответ-на-свой-вопрос-куда-мне-обратиться"><a class="header" href="#Я-не-могу-найти-здесь-ответ-на-свой-вопрос-куда-мне-обратиться">Я не могу найти здесь ответ на свой вопрос, куда мне обратиться?</a></h3>
<ul>
<li>Проверьте основной <a href="readme.html">файл readme</a>.</li>
<li>Ознакомьтесь с <a href="TROUBLESHOOTING.html">руководством по устранению неполадок</a>.</li>
<li>Проверьте <a href="https://github.com/cleolibrary/CLEO-Redux/issues">вопросы GitHub</a>.</li>
<li>Проверьте <a href="https://github.com/cleolibrary/CLEO-Redux/wiki/Feature-Support-Matrix">страницу поддержки функций</a>.</li>
<li>Задать вопрос в <a href="https://discord.gg/d5dZSfgBZr">нашем Discord</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Другие-особенности"><a class="header" href="#Другие-особенности">Другие особенности</a></h1>
<p>CLEO Redux фокусируется на улучшении опыта разработки и упрощении процесса написания сценариев. </p>
<h2 id="Интеграция-с-visual-studio-code"><a class="header" href="#Интеграция-с-visual-studio-code">Интеграция с Visual Studio Code</a></h2>
<p><a href="https://youtu.be/jqz8_lGnG4g">Демонстрация на YouTube</a></p>
<p>VS Code имеет широкие возможности настройки.  CLEO Redux генерирует типизации для всех поддерживаемых команд, которые вы можете использовать при написании JavaScript в VS Code.  Добавьте следующую строку в свой скрипт <code>*.js</code>, чтобы получить полную поддержку автозаполнения:</p>
<p>Для <code>GTA III</code> или <code>re3</code>:</p>
<pre><code>/// &lt;reference path=&quot;.config/gta3.d.ts&quot; /&gt;
</code></pre>
<p>Для <code>Vice City</code> или <code>reVC</code></p>
<pre><code>/// &lt;reference path=&quot;.config/vc.d.ts&quot; /&gt;
</code></pre>
<p>Для <code>San Andreas</code></p>
<pre><code>/// &lt;reference path=&quot;.config/sa.d.ts&quot; /&gt;
</code></pre>
<p>Эта строка указывает VS Code, где искать определения команд для функции автозаполнения. Путь может быть относительным относительно файла сценария или быть абсолютным. <a href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-path-">Дополнительную информацию</a> на официальном портале TypeScript.</p>
<h2 id="scm-Лог"><a class="header" href="#scm-Лог">SCM Лог</a></h2>
<p>CLEO Redux имеет встроенную поддержку отслеживания инструкций SCM. Чтобы включить трассировку для выполняемых команд, откройте <code>cleo.ini</code> и измените <code>LogOpcodes</code> на 1. Обратите внимание, что это может сильно повлиять на производительность игры из-за частых микрозадержек во время записи в файл журнала. Используйте этот параметр только в целях отладки.</p>
<h2 id="Горячая-перезагрузка"><a class="header" href="#Горячая-перезагрузка">Горячая перезагрузка</a></h2>
<p>CLEO отслеживает активные скрипты и перезагружает их в игре по мере их изменения</p>
<p><a href="https://www.youtube.com/watch?v=WanLojClqFw">Демонстрация на YouTube</a></p>
<p>Добавление нового файла скрипта в директорию CLEO или удаление во время игры запускает или останавливает скрипт автоматически</p>
<p><a href="https://www.youtube.com/watch?v=LAi2syrsxJg">Демонстрация на YouTube</a></p>
<p>Горячая перезагрузка для CS-скриптов не работает, когда CLEO Redux работает вместе с CLEO Library (например, в классическом San Andreas).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-fxt"><a class="header" href="#Использование-fxt">Использование FXT</a></h2>
<h3 id="Статические-файлы-fxt"><a class="header" href="#Статические-файлы-fxt">Статические файлы FXT</a></h3>
<p>Демонстрация: https://youtu.be/ctsKy7WnY9o</p>
<p>CLEO Redux может загружать и обслуживать статический текстовый контент. Создайте новый файл с расширением <code>.fxt</code> и поместите его в папку <code>CLEO\CLEO_TEXT</code>. Имя файла может быть любым допустимым именем.</p>
<p>Каждый файл FXT содержит список записей ключ-значение в следующем формате:</p>
<pre><code>&lt;KEY1&gt; &lt;TEXT1&gt;
&lt;KEY2&gt; &lt;TEXT2&gt;
...
&lt;KEYN&gt; &lt;TEXTN&gt;
</code></pre>
<p>Между ключом и значением должен быть один пробел. Максимальная длина ключа составляет 7 символов. Попробуйте использовать уникальные ключи, которые вряд ли будут конфликтовать с другими записями. Длина текста не ограничена, однако каждая игра может накладывать свои ограничения.</p>
<p>CLEO загружает файлы FXT при запуске и объединяет их содержимое в один словарь. Он также отслеживает файлы и перезагружает их, если вносятся какие-либо изменения.</p>
<p>Вы также можете найти редактор файлов FXT на сайте cleo.li: https://cleo.li/download.html</p>
<p>Чтобы отобразить пользовательский контент в игре, используйте класс <code>Text</code>. Ключ, определенный в файле FXT, обычно является первым аргументом текстовых команд, например.</p>
<pre><code>Text.PrintHelp('KEY1') // будет отображаться &lt;TEXT1&gt;
</code></pre>
<p>Вы можете найти команды, доступные в каждой игре, в библиотеке Sanny Builder, например. для Сан-Андреас: DE https://library.sannybuilder.com/#/sa_unreal/classes/Text</p>
<h3 id="fxtstore-1"><a class="header" href="#fxtstore-1">FxtStore</a></h3>
<p>Демонстрация: https://youtu.be/FLyYyrGz1Xg</p>
<p>CLEO Redux предоставляет интерфейс для управления произвольным текстом непосредственно в коде JavaScript. Существует статическая переменная с именем <code>FxtStore</code> со следующим интерфейсом:</p>
<pre><code class="language-ts">declare interface FxtStore {
  /**
   * Вставляет новое текстовое содержимое в хранилище fxt сценария, перезаписывая предыдущее содержимое и затеняя статические fxt с тем же ключом.
   * Ключ @param Ключ GXT, который можно использовать в текстовых командах (максимум 7 символов).
   * Текстовое содержимое значения @param.
   */
  insert(key: string, value: string): void;
  /**
   * Удаляет текстовое содержимое, связанное с ключом, в локальном хранилище fxt.
   * Ключ @param Ключ GXT.
   */
  delete(key: string): void;
}
</code></pre>
<p>Используя <code>FxtStore</code>, вы можете создавать уникальные ключи и значения в сценарии и помещать их в локальное хранилище FXT. Каждому скрипту принадлежит личное хранилище, и ключи одного скрипта не будут конфликтовать с другими скриптами. Также ключи, определенные в FxtStore, будут дублировать те же ключи, что и в статических файлах FXT. Рассмотрим пример:</p>
<p>custom.fxt:</p>
<pre><code>MY_KEY Text from FXT file
</code></pre>
<p>custom.js:</p>
<pre><code class="language-js">Text.PrintHelp('MY_KEY') // Это отображает &quot;Текст из файла FXT&quot;.
FxtStore.insert('MY_KEY', 'Text from script');
Text.PrintHelp('MY_KEY') // Это отображает &quot;Текст из сценария&quot;.
FxtStore.delete('MY_KEY')
Text.PrintHelp('MY_KEY') // Это отображает &quot;Текст из файла FXT&quot; снова.
</code></pre>
<p>Частное хранилище FXT не поддерживается в San Andreas: The Definitive Edition. Каждый скрипт изменяет глобальное хранилище FXT. Это поведение может измениться в будущем.</p>
<p>Пользовательский текст может создаваться динамически, например:</p>
<pre><code class="language-js">while(true) {
    wait(0);
    FxtStore.insert('TIME', 'Timestamp: ' + Date.now());
    Text.PrintHelp('TIME') // Отобразится &quot;Timestamp: &quot; и обновленное значение timestamp.
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Неподдерживаемые-или-ограниченные-сценарии-поддержки"><a class="header" href="#Неподдерживаемые-или-ограниченные-сценарии-поддержки">Неподдерживаемые или ограниченные сценарии поддержки</a></h2>
<p>Несмотря на все наши усилия, некоторые сценарии, доступные в игре, не поддерживаются или поддерживаются с ограничениями CLEO Redux. Некоторые из них обусловлены природой формата SCM или языка JavaScript или трудностями соединения JavaScript и нативного кода.</p>
<p>Посетите <a href="https://github.com/cleolibrary/CLEO-Redux/wiki/Feature-Support-Matrix">страницу поддержки функций</a> чтобы узнать высокоуровневые фичи и статус их поддержки в разных играх.</p>
<p>Известно, что следующие элементы не работают, и нет конкретных сроков их исправления.</p>
<h3 id="Неподдерживаемые-функции-в-cs"><a class="header" href="#Неподдерживаемые-функции-в-cs">Неподдерживаемые функции в CS</a></h3>
<ul>
<li>В играх x64 (SA:DE) вы не можете читать и записывать 64-битные значения, так как скриптовый движок поддерживает только 32-битные значения. Возможно, вам придется использовать другие средства для доступа к памяти игры (например, из JavaScript).</li>
</ul>
<h3 id="Неподдерживаемые-функции-в-js"><a class="header" href="#Неподдерживаемые-функции-в-js">Неподдерживаемые функции в JS</a></h3>
<ul>
<li>
<p>Команды, требующие переменной scm (например, таймеры обратного отсчета). <a href="https://github.com/cleolibrary/CLEO-Redux/issues/10">Проблема с отслеживанием</a>.</p>
</li>
<li>
<p>Команды, неявно загружающие модели или текстуры (например, виджеты) <a href="https://github.com/cleolibrary/CLEO-Redux/issues/12">Проблема с отслеживанием</a>. Вы можете обойти проблему, предварительно загрузив необходимые ресурсы, например. сначала вызывая их в сценарии <code>.CS</code>.</p>
</li>
<li>
<p>нельзя вызывать игровые функции, которым нужны ссылки на переменные для сохранения результата. Нет синтаксиса &quot;take an address of the variable&quot;.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Встраивание-на-пользовательских-хостах"><a class="header" href="#Встраивание-на-пользовательских-хостах">Встраивание на пользовательских хостах</a></h1>
<blockquote>
<p>Над этой документацией ведется работа.</p>
</blockquote>
<p>CLEO Redux может встраивать и запускать JS-скрипты на неизвестном (т.е. не <a href="./introduction.html#supported-releases">поддерживаемом официально</a>) хосте.  <em>Хост</em> — это приложение, в котором загружается или внедряется процесс cleo_redux.asi или cleo_redux64.asi и в котором работает среда выполнения CLEO. Эта функция является экспериментальной и может быть изменена в любой момент.</p>
<p><a href="https://www.youtube.com/watch?v=rk2LvDt7UkI">Демонстрация на YouTube</a>.</p>
<h2 id="Загрузка-в-пользовательский-процесс"><a class="header" href="#Загрузка-в-пользовательский-процесс">Загрузка в пользовательский процесс</a></h2>
<p>Существует несколько способов загрузки файла ASI в целевой процесс. <a href="https://github.com/ThirteenAG/Ultimate-ASI-Loader/releases">Ultimate ASI Loader</a> — один из них. Или используйте любой <a href="https://github.com/search?q=dll+injector">DLL-инжектор</a>, доступный на GitHub. При необходимости хост может самостоятельно загрузить файл CLEO ASI как динамическую библиотеку.</p>
<h2 id="Запуск-среды-выполнения-cleo"><a class="header" href="#Запуск-среды-выполнения-cleo">Запуск среды выполнения CLEO</a></h2>
<p>Чтобы запустить CLEO на неизвестном хосте сразу после загрузки (в автономном режиме), откройте <a href="./config.html">файл конфигурации</a> и установите <code>EnableSelfHost</code> на <code>1</code>. CLEO Redux автоматически сканирует <a href="./cleo-directory.html">директорию CLEO</a> на наличие плагинов и скриптов и запускает их.</p>
<h3 id="Ручное-управление-средой-выполнения"><a class="header" href="#Ручное-управление-средой-выполнения">Ручное управление средой выполнения</a></h3>
<p>Хост может запускать среду выполнения и продвигать ее основной цикл с помощью методов SDK <code>RuntimeInit</code> и <code>RuntimeNextTick</code>.</p>
<p>Вот как это можно реализовать на Rust:</p>
<pre><code class="language-toml">[dependencies]
ctor = &quot;0.1.21&quot;
cleo_redux_sdk = &quot;0.0.6&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time;
use ctor::*;
use cleo_redux_sdk;

#[cfg_attr(target_arch = &quot;x86&quot;, link(name = &quot;cleo_redux&quot;))]
#[cfg_attr(target_arch = &quot;x86_64&quot;, link(name = &quot;cleo_redux64&quot;))]

#[ctor]
fn init() {
    use std::thread;

    // загружаем CLEO-скрипты, FXT, включаем файловый наблюдатель
    cleo_redux_sdk::runtime_init();

    // переменные времени инициализации
    const FPS: i32 = 30;
    let time_step = 1000 / FPS;
    let started = time::Instant::now();

    thread::spawn(move || loop {
        let current_time = started.elapsed().as_millis() as u32;

        // продвигаем основной цикл, предоставляя значения current_time и time_step
        // current_time используется для определения того, должен ли скрипт &quot;просыпаться&quot; после команды ожидания.
        // time_step используется для увеличения переменных TIMERA и TIMERB
        cleo_redux_sdk::runtime_next_tick(current_time, time_step);


        // пауза по крайней мере на time_step миллисекунд
        thread::sleep(time::Duration::from_millis(time_step as u64));
    });
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="Доступные-команды"><a class="header" href="#Доступные-команды">Доступные команды</a></h2>
<p>В автономном режиме CLEO Redux поддерживает собственные <a href="./js-bindings.html">переменные и функции</a> и команды, созданные с помощью <a href="./using-sdk.html">SDK</a>. Он использует определения команд для неизвестного хоста из библиотеки Sanny Builder (доступно для <a href="https://library.sannybuilder.com/#/unknown_x86">32-разрядных</a> и <a href="https://library.sannybuilder.com/#/unknown_x64">64-разрядных</a>). CLEO Redux автоматически загружает необходимые файлы при <a href="./prerequisites.html">первом запуске</a>.</p>
<p>Вы можете использовать все стандартные функции JavaScript.  Список доступных команд можно увидеть в автоматически сгенерированном файле <code>.config/unknown.d.ts</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cleo-redux-sdk"><a class="header" href="#cleo-redux-sdk">CLEO Redux SDK</a></h2>
<p>SDK позволяет создавать новые скриптовые команды для любой игры, которую поддерживает CLEO Redux. Он не зависит от названия игры и базовой среды выполнения (CS или JS). На данный момент CLEO предоставляет SDK для языков C++ и Rust.</p>
<h3 id="Поддержка-платформ"><a class="header" href="#Поддержка-платформ">Поддержка платформ</a></h3>
<p>CLEO Redux предоставляет SDK как для 32-битных, так и для 64-битных игр. Между ними есть одно заметное отличие: на 32-битной платформе функции SDK <code>GetIntParam</code> и <code>SetIntParam</code> работают с 32-битными числами со знаком, тогда как на 64-битной платформе они работают с 64-битными числами со знаком (объявлено как тип <code>isize</code>).</p>
<h3 id="Структура-плагина"><a class="header" href="#Структура-плагина">Структура плагина</a></h3>
<p>Каждый плагин представляет собой динамическую библиотеку с расширением <code>.cleo</code>, которую необходимо поместить в <code>CLEO\CLEO_PLUGINS</code>. CLEO Redux сканирует этот каталог при запуске и загружает все файлы <code>.cleo</code>, используя функцию WinAPI <code>LoadLibrary</code>. Чтобы зарегистрировать обработчик для новой команды, плагин должен вызвать <code>RegisterCommand</code> в функции DllMain. Как только пользовательский скрипт встречает эту команду, CLEO Redux вызывает обработчик с одним аргументом, который является указателем на текущий контекст. Этот указатель необходимо использовать для вызова других методов SDK.</p>
<h3 id="Соглашение-об-именовании"><a class="header" href="#Соглашение-об-именовании">Соглашение об именовании</a></h3>
<p>Для 64-битных плагинов рекомендуется использовать <code>64</code> в именах (например, <code>myplugin64.cleo</code>).</p>
<h3 id="Небезопасные-команды"><a class="header" href="#Небезопасные-команды">Небезопасные команды</a></h3>
<p>Команды, использующие низкоуровневый WinAPI и потенциально способные нанести вред среде пользователя, должны быть явно зарегистрированы с помощью токена разрешения (третий аргумент <code>RegisterCommand</code>). Пользователь может запретить использование небезопасных команд в скриптах с помощью <a href="https://github.com/TheFantomKiller420/CLEO-Redux-rus-local/blob/master/readme.md#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">настройки разрешений</a>. На данный момент используются три токена разрешений: <code>mem</code>, <code>fs</code> и <code>dll</code>. Ими отмечаются команды, работающие с хост-процессом, пользовательскими файлами и внешними библиотеками.</p>
<h3 id="Командный-интерфейс"><a class="header" href="#Командный-интерфейс">Командный интерфейс</a></h3>
<p>CLEO Redux использует <a href="https://library.sannybuilder.com">Sanny Builder Library</a>, чтобы узнать интерфейс любой команды. Чтобы новая команда стала доступной в сценариях, файл JSON (<code>gta3.json</code>, <code>vc.json</code>, <code>sa.json</code>) должен иметь определение команды, включая имя, совпадающее со значением, которое плагин использует <code>RegisterCommand</code> с. Например. если подключаемый модуль регистрирует команду <code>SHOW_MESSAGE</code>, в файле JSON должна быть команда со свойством имени, установленным на <code>SHOW_MESSAGE</code>. Количество и порядок входных и выходных параметров в определении должны соответствовать порядку методов, используемых подключаемым модулем (т. е. <code>GetXXXParam</code> для каждого входного аргумента и <code>SetXXXParam</code> для каждого выходного аргумента).</p>
<h4 id="Запрос-кодов-операций"><a class="header" href="#Запрос-кодов-операций">Запрос кодов операций</a></h4>
<p>Коды операций назначаются новым командам в Sanny Builder Library в зависимости от их доступности, сходства с существующими командами в других играх и других факторов. Чтобы запросить код операции, обратитесь к сопровождающим Sanny Builder Library на GitHub https://github.com/sannybuilder/library/issues.</p>
<h4 id="Зачем-использовать-имена-команд-а-не-идентификатор-для-поиска-команды"><a class="header" href="#Зачем-использовать-имена-команд-а-не-идентификатор-для-поиска-команды">Зачем использовать имена команд, а не идентификатор для поиска команды?</a></h4>
<p>Одной из распространенных проблем с плагинами CLEO Library было то, что команды, созданные разными людьми, часто имели конфликты идентификаторов. Если два плагина добавляют команды с одинаковым идентификатором, использовать их оба невозможно. Использование строковых имен сводит к минимуму коллизии с пользовательскими плагинами, а также с собственными кодами операций. Определения библиотеки гарантируют, что каждая команда требует только доступный идентификатор. Также это помогает отслеживать и документировать плагины в одном месте.</p>
<h3 id="Версия-sdk"><a class="header" href="#Версия-sdk">Версия SDK</a></h3>
<p>Текущая версия <code>1</code>. Изменения в SDK увеличат это число на единицу.</p>
<h3 id="Соглашение-о-разрешении-пути"><a class="header" href="#Соглашение-о-разрешении-пути">Соглашение о разрешении пути</a></h3>
<p>Строковые аргументы, представляющие путь к каталогу или файлу, должны быть нормализованы с помощью функции SDK <code>ResolvePath</code>. Эта функция принимает путь и возвращает абсолютный путь, разрешенный по следующим правилам:</p>
<ul>
<li>абсолютный путь разрешается как есть</li>
<li>путь, начинающийся с &quot;CLEO/&quot; или &quot;CLEO\&quot;, разрешается относительно каталога CLEO, который либо
<ul>
<li>{игра}\CLEO или</li>
<li>{пользователь}\AppData\Roaming\CLEO Redux\CLEO</li>
</ul>
</li>
<li>все остальные пути разрешаются относительно текущего рабочего каталога (каталог игры)</li>
</ul>
<h3 id="Строковые-аргументы"><a class="header" href="#Строковые-аргументы">Строковые аргументы</a></h3>
<p>Строки, передаваемые в методы SDK имеют кодировку UTF-8.</p>
<p>Если сценарий использует целочисленное значение вместо ожидаемой строки, SDK обрабатывает это число как указатель на последовательность символов UTF-8, заканчивающуюся нулем, для чтения или на достаточно большой буфер для сохранения результата:</p>
<pre><code class="language-js">IniFile.WriteString(0xDEADBEEF, &quot;my.ini&quot;, &quot;section&quot;, &quot;key&quot;)
</code></pre>
<p>SDK прочитает строку с адреса <code>0xDEADBEEF</code> и запишет ее в ini-файл.</p>
<pre><code>0AF4: read_string_from_ini_file 'my.ini' section 'section' key 'key' store_to 0xDEADBEEF
</code></pre>
<p>SDK прочитает строку из ini-файла и запишет ее по адресу <code>0xDEADBEEF</code>.</p>
<h3 id="c-sdk"><a class="header" href="#c-sdk">C++ SDK</a></h3>
<p>Пользовательские плагины могут вызывать методы, предоставляемые CLEO Redux, используя предоставленный файл <code>.lib</code>. Включите <code>cleo_redux_sdk.h</code> в свой проект DLL и свяжите двоичный файл с <code>cleo_redux.lib</code> (или <code>cleo_redux64.lib</code>, если целевая платформа x86_64), и вы сможете начать писать новые команды.</p>
<h4 id="Пример"><a class="header" href="#Пример">Пример</a></h4>
<p>См. подключаемый модуль <code>IniFiles</code>, который включает проект для Visual Studio 2019. Он добавляет статический класс <code>IniFile</code> со следующими методами:</p>
<pre><code class="language-ts">interface IniFile {
    ReadFloat(path: string, section: string, key: string): float | undefined;
    ReadInt(path: string, section: string, key: string): int | undefined;
    ReadString(path: string, section: string, key: string): string | undefined;
    WriteFloat(value: float, path: string, section: string, key: string): boolean;
    WriteInt(value: int, path: string, section: string, key: string): boolean;
    WriteString(value: string, path: string, section: string, key: string): boolean;
}
</code></pre>
<p>Дополнительную информацию см. в библиотеке Sanny Builder: https://library.sannybuilder.com/#/sa_unreal/classes/IniFile. Для использования класса <code>IniFile</code> требуется <code>fs</code> <a href="readme.html#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">разрешение</a>.</p>
<h3 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h3>
<p>Rust SDK использует интерфейс, аналогичный интерфейсу C++, с некоторыми дополнительными методами переноса, позволяющими легко конвертировать типы C и Rust. Заголовочный файл доступен в виде <a href="https://crates.io/crates/cleo_redux_sdk">crate</a> на crates.io. См. документацию <a href="https://docs.rs/cleo_redux_sdk/latest/">здесь</a>.</p>
<h4 id="Пример-1"><a class="header" href="#Пример-1">Пример</a></h4>
<p>См. плагин <code>Dylib</code>. Он добавляет класс <code>DynamicLibrary</code> со следующими методами:</p>
<pre><code class="language-ts">declare class DynamicLibrary {
    constructor(handle: number);
    static Load(libraryFileName: string): DynamicLibrary | undefined;
    free(): void;
    getProcedure(procName: string): int | undefined;
}
</code></pre>
<p>Дополнительную информацию см. в Sanny Builder Library: https://library.sannybuilder.com/#/sa_unreal/classes/DynamicLibrary. Для использования класса <code>DynamicLibrary</code> требуется <code>dll</code> <a href="readme.html#%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F">разрешение</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-sdk-1"><a class="header" href="#c-sdk-1">C++ SDK</a></h1>
<p>На этой странице описаны основные шаги, необходимые для создания новой пользовательской команды с помощью C++ SDK, которая считывает два целочисленных аргумента и возвращает их сумму.</p>
<p>Это руководство было проверено для Visual Studio 2019 (Community Edition) и может отличаться для других IDE и компиляторов.</p>
<h2 id="Разработка-плагина"><a class="header" href="#Разработка-плагина">Разработка плагина</a></h2>
<ul>
<li>
<p>Создайте новый проект библиотеки динамической компоновки (DLL).  В <code>Настройки проекта-&gt;Дополнительно</code> установите для <code>Расширение целевого файла</code> значение <code>.cleo</code>.</p>
</li>
<li>
<p>Загрузите <a href="https://raw.githubusercontent.com/cleolibrary/CLEO-Redux/master/plugins/SDK/cleo_redux_sdk.h"><code>cleo_redux_sdk.h</code></a> и добавьте его в свой проект.</p>
</li>
</ul>
<pre><code class="language-cpp">#include &quot;cleo_redux_sdk.h&quot;
</code></pre>
<p>Если этот заголовочный файл находится за пределами каталога вашего проекта, вам необходимо добавить папку с этим файлом в «Настройки проекта-&gt;Каталоги VC++-&gt;Включить каталоги», чтобы позволить Visual Studio обнаружить этот файл.</p>
<ul>
<li>
<p>В <code>Настройки проекта-&gt;Линкер-&gt;Вход</code> добавьте полный путь к <a href="https://github.com/cleolibrary/CLEO-Redux/raw/master/plugins/SDK/cleo_redux.lib"><code>cleo_redux.lib</code></a> (если вы разрабатываете 32-битный плагин) или в <a href="https://github.com/cleolibrary/CLEO-Redux/blob/master/plugins/SDK/cleo_redux64.lib"><code>cleo_redux64.lib</code></a> для 64-битного плагина.</p>
</li>
<li>
<p>в <code>dllmain.cpp</code> создайте новый статический класс с функцией-конструктором.  Этот конструктор будет вызван, как только CLEO загрузит ваш плагин</p>
</li>
</ul>
<pre><code class="language-cpp">class TestPlugin {
public:
	TestPlugin() {
		Log(&quot;My Test Plugin&quot;);
	}
} TestPlugin;
</code></pre>
<ul>
<li>в конструкторе класса плагина вызовите функцию <code>RegisterCommand</code> для каждой новой команды</li>
</ul>
<pre><code class="language-cpp">class TestPlugin {
public:
	TestPlugin() {
		Log(&quot;My Test Plugin&quot;);
        RegisterCommand(&quot;INT_ADD&quot;, IntAdd);
	}

    static HandlerResult IntAdd(Context ctx) {
        return HandlerResult::CONTINUE;
    }
} TestPlugin;
</code></pre>
<ul>
<li>реализуйте обработчики для новых команд.  Каждый обработчик команд получает один входной аргумент — <code>Context ctx</code>. Этот аргумент используется для вызова других методов SDK.</li>
</ul>
<pre><code class="language-cpp">class TestPlugin {
public:
	TestPlugin() {
		Log(&quot;My Test Plugin&quot;);
        RegisterCommand(&quot;INT_ADD&quot;, IntAdd);
	}

    static HandlerResult IntAdd(Context ctx) {
        auto arg1 = GetIntParam(ctx);
        auto arg2 = GetIntParam(ctx);
        SetIntParam(ctx, arg1 + arg2);

        return HandlerResult::CONTINUE;
    }
} TestPlugin;
</code></pre>
<ul>
<li>
<p>скомпилируйте проект и поместите файл <code>.cleo</code> в папку <a href="./installation-plugins.html"><code>CLEO_PLUGINS</code></a>.</p>
</li>
<li>
<p>добавить определение команды в файл JSON для целевой игры (например, <code>gta3.json</code> для GTA III или <code>unknown_x86.json</code> для хоста Unknown (x86)).  Каждый <code>GetXXXParam</code>/<code>SetXXXParam</code> должен быть связан с вводом или выводом в определении команды.</p>
</li>
</ul>
<pre><code class="language-json">{
    &quot;input&quot;: [
        { &quot;name&quot;: &quot;arg1&quot;, &quot;type&quot;: &quot;int&quot; },
        { &quot;name&quot;: &quot;arg2&quot;, &quot;type&quot;: &quot;int&quot; }
    ],
    &quot;output&quot;: [
        { &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;int&quot;, &quot;source&quot;: &quot;var_any&quot; }
    ],
    &quot;id&quot;: &quot;0DDD&quot;,
    &quot;name&quot;: &quot;INT_ADD&quot;,
    &quot;num_params&quot;: 3,
    &quot;short_desc&quot;: &quot;Adds together two integer values and writes the result into the variable&quot;,
},
</code></pre>
<p><code>id</code> необязателен для неизвестных хостов.  Для известных и поддерживаемых игр идентификатор должен быть уникальным кодом операции, который больше нигде не используется.</p>
<p>Лучший способ создать правильное определение команды — использовать <a href="https://library.sannybuilder.com/">Sanny Builder Library</a>. Если вы планируете поделиться подключаемым модулем и сделать его доступным через Интернет, подумайте о том, чтобы связаться с сопровождающими библиотеки, чтобы ваша команда была опубликована там.</p>
<ul>
<li>теперь вы можете использовать новую команду в коде с помощью команды <a href="./js-bindings.html#native"><code>native</code></a></li>
</ul>
<pre><code class="language-js">var result = native(&quot;INT_ADD&quot;, 10, 20); // 30
</code></pre>
<h2 id="Пример-2"><a class="header" href="#Пример-2">Пример</a></h2>
<p>См. подключаемый модуль <a href="https://library.sannybuilder.com/#/sa_unreal/classes/IniFile"><code>IniFiles</code></a>, который включает полный проект для Visual Studio 2019.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk-1"><a class="header" href="#rust-sdk-1">Rust SDK</a></h1>
<p>Rust SDK использует интерфейс, аналогичный интерфейсу C++, с некоторыми дополнительными методами переноса, позволяющими легко конвертировать типы C и Rust. Заголовочный файл доступен в виде <a href="https://crates.io/crates/cleo_redux_sdk">crate</a> на crates.io.  См. документацию <a href="https://docs.rs/cleo_redux_sdk/latest/">здесь</a>.</p>
<h2 id="Пример-3"><a class="header" href="#Пример-3">Пример</a></h2>
<p>Рассмотрим плагин <code>Dylib</code>.  Он добавляет класс DynamicLibrary со следующими методами:</p>
<pre><code class="language-ts">declare class DynamicLibrary {
    constructor(handle: number);
    static Load(libraryFileName: string): DynamicLibrary | undefined;
    free(): void;
    getProcedure(procName: string): int | undefined;
}
</code></pre>
<p><a href="https://library.sannybuilder.com/#/sa_unreal/classes/DynamicLibrary">Дополнительная информация</a> в библиотеке Sanny Builder.  Для использования класса <code>DynamicLibrary</code> требуется <code>dll</code> <a href="./permissions.html">разрешение</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
